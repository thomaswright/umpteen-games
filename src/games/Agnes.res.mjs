// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "../Card.res.mjs";
import * as Bases from "./Bases.res.mjs";
import * as Boards from "./Boards.res.mjs";
import * as Common from "../Common.res.mjs";
import * as Spider from "./Spider.res.mjs";
import * as FreeCell from "./FreeCell.res.mjs";
import * as GameBase from "../GameBase.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as GameCommons from "./GameCommons.res.mjs";

function initiateGame() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  var beak = Common.ArrayAux.popN(deckToDeal, 1);
  var piles = [
    Common.ArrayAux.popN(deckToDeal, 1),
    Common.ArrayAux.popN(deckToDeal, 2),
    Common.ArrayAux.popN(deckToDeal, 3),
    Common.ArrayAux.popN(deckToDeal, 4),
    Common.ArrayAux.popN(deckToDeal, 5),
    Common.ArrayAux.popN(deckToDeal, 6),
    Common.ArrayAux.popN(deckToDeal, 7)
  ];
  var stock = [
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 2), 0),
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 7), 0),
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 7), 0),
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 7), 0)
  ];
  return [
          shuffledDeck,
          {
            piles: piles,
            foundations: [
              beak,
              [],
              [],
              []
            ],
            stock: stock,
            waste: [],
            free: []
          }
        ];
}

function foundationBaseCheck(game, dragPile, i) {
  var justOne = dragPile.length === 1;
  var noChildren = game.foundations[i].length === 0;
  var dragPileBase = dragPile[0];
  var beak = game.foundations[0][0];
  if (noChildren && justOne) {
    return dragPileBase.card.rank === beak.card.rank;
  } else {
    return false;
  }
}

function foundationBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              if (foundationBaseCheck(game, dragPile, i)) {
                return {
                        piles: GameCommons.flipLastUp(game.piles),
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                return dragPile;
                              })),
                        stock: game.stock,
                        waste: game.waste,
                        free: game.free
                      };
              }
              
            }),
          autoProgress: "Seek",
          onClick: (function (param) {
              
            })
        };
}

var forEachSpace = Bases.AgnesSorel.makeForEachSpace(undefined, undefined, foundationBaseRules, undefined, undefined, undefined, Spider.SpiderRules.stockRules, undefined, undefined);

var Sorel = GameBase.Create({
      game_encode: Bases.AgnesSorel.game_encode,
      game_decode: Bases.AgnesSorel.game_decode,
      deck_encode: Bases.AgnesSorel.deck_encode,
      deck_decode: Bases.AgnesSorel.deck_decode,
      getSpace: Bases.AgnesSorel.getSpace,
      spaceToString: Bases.AgnesSorel.spaceToString,
      initiateGame: initiateGame,
      forEachSpace: forEachSpace,
      removeDragFromGame: Bases.AgnesSorel.removeDragFromGame,
      winCheck: Bases.AgnesSorel.winCheck,
      applyLiftToDragPile: Bases.AgnesSorel.applyLiftToDragPile,
      applyMoveToDragPile: Bases.AgnesSorel.applyMoveToDragPile,
      Board: Boards.Spider,
      AllCards: Bases.AgnesSorel.AllCards
    });

function initiateGame$1() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  var beak = Common.ArrayAux.popN(deckToDeal, 1);
  var piles = [
    Common.ArrayAux.popN(deckToDeal, 1),
    Common.ArrayAux.popN(deckToDeal, 2),
    Common.ArrayAux.popN(deckToDeal, 3),
    Common.ArrayAux.popN(deckToDeal, 4),
    Common.ArrayAux.popN(deckToDeal, 5),
    Common.ArrayAux.popN(deckToDeal, 6),
    Common.ArrayAux.popN(deckToDeal, 7)
  ];
  var free = [
    Common.ArrayAux.popN(deckToDeal, 1)[0],
    Common.ArrayAux.popN(deckToDeal, 1)[0],
    Common.ArrayAux.popN(deckToDeal, 1)[0],
    Common.ArrayAux.popN(deckToDeal, 1)[0],
    Common.ArrayAux.popN(deckToDeal, 1)[0],
    Common.ArrayAux.popN(deckToDeal, 1)[0],
    Common.ArrayAux.popN(deckToDeal, 1)[0]
  ];
  var stock = [
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 2), 0),
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 7), 0),
    Card.hideAfter(Common.ArrayAux.popN(deckToDeal, 7), 0)
  ];
  var game_foundations = [
    beak,
    [],
    [],
    []
  ];
  var game_waste = [];
  var game = {
    piles: piles,
    foundations: game_foundations,
    stock: stock,
    waste: game_waste,
    free: free
  };
  return [
          shuffledDeck,
          game
        ];
}

function foundationBaseCheck$1(game, dragPile, i) {
  var justOne = dragPile.length === 1;
  var noChildren = game.foundations[i].length === 0;
  var dragPileBase = dragPile[0];
  var beak = game.foundations[0][0];
  if (noChildren && justOne) {
    return dragPileBase.card.rank === beak.card.rank;
  } else {
    return false;
  }
}

function foundationBaseRules$1(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              if (foundationBaseCheck$1(game, dragPile, i)) {
                return {
                        piles: GameCommons.flipLastUp(game.piles),
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                return dragPile;
                              })),
                        stock: game.stock,
                        waste: game.waste,
                        free: game.free
                      };
              }
              
            }),
          autoProgress: "Seek",
          onClick: (function (param) {
              
            })
        };
}

function pileBaseRules(game, i) {
  return {
          droppedUpon: (function (gameRemoved, dragPile) {
              var dragPileBase = dragPile[0];
              var noChildren = game.piles[i].length === 0;
              var beak = game.foundations[0][0];
              if (noChildren && Card.rankIsAboveCyclic(beak, dragPileBase)) {
                return {
                        piles: GameCommons.flipLastUp(Common.ArrayAux.update(gameRemoved.piles, i, (function (param) {
                                    return dragPile;
                                  }))),
                        foundations: gameRemoved.foundations,
                        stock: gameRemoved.stock,
                        waste: gameRemoved.waste,
                        free: gameRemoved.free
                      };
              }
              
            }),
          autoProgress: "Accept",
          onClick: (function (param) {
              
            })
        };
}

var forEachSpace$1 = Bases.AgnesBernauer.makeForEachSpace(pileBaseRules, undefined, foundationBaseRules$1, undefined, undefined, undefined, Spider.SpiderRules.stockRules, FreeCell.FreeCellRules.freeBaseRules, FreeCell.FreeCellRules.freeRules);

var Bernauer = GameBase.Create({
      game_encode: Bases.AgnesBernauer.game_encode,
      game_decode: Bases.AgnesBernauer.game_decode,
      deck_encode: Bases.AgnesBernauer.deck_encode,
      deck_decode: Bases.AgnesBernauer.deck_decode,
      getSpace: Bases.AgnesBernauer.getSpace,
      spaceToString: Bases.AgnesBernauer.spaceToString,
      initiateGame: initiateGame$1,
      forEachSpace: forEachSpace$1,
      removeDragFromGame: Bases.AgnesBernauer.removeDragFromGame,
      winCheck: Bases.AgnesBernauer.winCheck,
      applyLiftToDragPile: Bases.AgnesBernauer.applyLiftToDragPile,
      applyMoveToDragPile: Bases.AgnesBernauer.applyMoveToDragPile,
      Board: Boards.AgnesBernauer,
      AllCards: Bases.AgnesBernauer.AllCards
    });

export {
  Sorel ,
  Bernauer ,
}
/* Sorel Not a pure module */
