// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "../Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as Tarot from "../Tarot.res.mjs";
import * as React from "react";
import * as Common from "../Common.res.mjs";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as GameBase from "../GameBase.res.mjs";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function item_encode(value) {
  if (value.TAG === "Card") {
    return [
            "Card",
            Card.card_encode(value._0)
          ];
  } else {
    return [
            "Tarot",
            Tarot.card_encode(value._0)
          ];
  }
}

function item_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Tarot" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Tarot.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Tarot",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function space_encode(value) {
  if (typeof value !== "object") {
    switch (value) {
      case "TarotUp" :
          return ["TarotUp"];
      case "TarotDown" :
          return ["TarotDown"];
      case "Free" :
          return ["Free"];
      
    }
  } else {
    switch (value.TAG) {
      case "Item" :
          return [
                  "Item",
                  item_encode(value._0)
                ];
      case "Foundation" :
          return [
                  "Foundation",
                  Decco.intToJson(value._0)
                ];
      case "Pile" :
          return [
                  "Pile",
                  Decco.intToJson(value._0)
                ];
      
    }
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Free" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Free"
                  };
          }
      case "Item" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = item_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Item",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "TarotDown" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "TarotDown"
                  };
          }
      case "TarotUp" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "TarotUp"
                  };
          }
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

var fullDeck = Core__Array.toShuffled(Card.getShuffledDeck().map(function (card) {
            return {
                    TAG: "Card",
                    _0: card
                  };
          }).concat(Tarot.getShuffledDeck().map(function (card) {
              return {
                      TAG: "Tarot",
                      _0: card
                    };
            })));

var deckToDeal = fullDeck.filter(function (card) {
      if (card.TAG === "Card") {
        return card._0.rank !== "RA";
      } else {
        return true;
      }
    });

function initiateGame() {
  return {
          piles: [
            deckToDeal.slice(0, 7),
            deckToDeal.slice(7, 14),
            deckToDeal.slice(14, 21),
            deckToDeal.slice(21, 28),
            deckToDeal.slice(28, 35),
            [],
            deckToDeal.slice(35, 42),
            deckToDeal.slice(42, 49),
            deckToDeal.slice(49, 56),
            deckToDeal.slice(56, 63),
            deckToDeal.slice(63, 70)
          ],
          foundations: [
            [{
                suit: "Clubs",
                rank: "RA"
              }],
            [{
                suit: "Diamonds",
                rank: "RA"
              }],
            [{
                suit: "Hearts",
                rank: "RA"
              }],
            [{
                suit: "Spades",
                rank: "RA"
              }]
          ],
          tarotUp: [],
          tarotDown: [],
          free: undefined
        };
}

function winCheck(game) {
  if (game.piles.every(function (pile) {
          return pile.length === 0;
        })) {
    return Core__Option.isNone(game.free);
  } else {
    return false;
  }
}

function removeDragFromGame(game, dragPile) {
  return {
          piles: game.piles.map(function (x) {
                return x.filter(function (sCard) {
                            return Caml_obj.notequal(sCard, dragPile);
                          });
              }),
          foundations: game.foundations.map(function (x) {
                return x.filter(function (sCard) {
                            return Caml_obj.notequal({
                                        TAG: "Card",
                                        _0: sCard
                                      }, dragPile);
                          });
              }),
          tarotUp: game.tarotUp,
          tarotDown: game.tarotDown,
          free: Core__Option.flatMap(game.free, (function (card) {
                  if (Caml_obj.notequal(card, dragPile)) {
                    return card;
                  }
                  
                }))
        };
}

function pileBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              var noChildren = game.piles[i].length === 0;
              if (noChildren) {
                return {
                        piles: Common.ArrayAux.update(game.piles, i, (function (param) {
                                return [dragPile];
                              })),
                        foundations: game.foundations,
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: game.free
                      };
              }
              
            }),
          autoProgress: false
        };
}

function pileRules(pile, item, i, j) {
  var isLast = j === (pile.length - 1 | 0);
  return {
          locationAdjustment: {
            x: 0,
            y: Math.imul(j, 20),
            z: j + 1 | 0
          },
          baseSpace: {
            TAG: "Pile",
            _0: i
          },
          dragPile: (function () {
              if (isLast) {
                return item;
              }
              
            }),
          autoProgress: (function () {
              if (isLast) {
                return {
                        TAG: "Send",
                        _0: item
                      };
              } else {
                return "DoNothing";
              }
            }),
          droppedUpon: (function (game, dragPile) {
              if (dragPile.TAG !== "Card") {
                if (item.TAG === "Card" || !(isLast && Tarot.rankIsAdjacent(item._0, dragPile._0))) {
                  return ;
                } else {
                  return {
                          piles: game.piles.map(function (stack) {
                                return Common.ArrayAux.insertAfter(stack, item, [dragPile]);
                              }),
                          foundations: game.foundations,
                          tarotUp: game.tarotUp,
                          tarotDown: game.tarotDown,
                          free: game.free
                        };
                }
              }
              var dragCard = dragPile._0;
              if (item.TAG !== "Card") {
                return ;
              }
              var card = item._0;
              if (isLast && Card.rankIsAdjacent(card, dragCard) && dragCard.suit === card.suit) {
                return {
                        piles: game.piles.map(function (stack) {
                              return Common.ArrayAux.insertAfter(stack, item, [dragPile]);
                            }),
                        foundations: game.foundations,
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: game.free
                      };
              }
              
            }),
          applyMoveToOthers: (function (param) {
              
            })
        };
}

function foundationBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              var noChildren = game.foundations[i].length === 0;
              if (dragPile.TAG !== "Card") {
                return ;
              }
              var card = dragPile._0;
              if (noChildren && card.rank === "RA") {
                return {
                        piles: game.piles,
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                return [card];
                              })),
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: game.free
                      };
              }
              
            }),
          autoProgress: true
        };
}

function foundationRules(card, i, j) {
  return {
          locationAdjustment: {
            x: 0,
            y: 0,
            z: j + 1 | 0
          },
          baseSpace: {
            TAG: "Foundation",
            _0: i
          },
          dragPile: (function () {
              
            }),
          autoProgress: (function () {
              return "Seek";
            }),
          droppedUpon: (function (game, dragPile) {
              if (dragPile.TAG !== "Card") {
                return ;
              }
              var dragCard = dragPile._0;
              if (dragCard.suit === card.suit && Card.rankIsBelow(card, dragCard)) {
                return {
                        piles: game.piles,
                        foundations: game.foundations.map(function (stack) {
                              return Common.ArrayAux.insertAfter(stack, card, [dragCard]);
                            }),
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: game.free
                      };
              }
              
            }),
          applyMoveToOthers: (function (param) {
              
            })
        };
}

function tarotUpBaseRules() {
  return {
          droppedUpon: (function (game, dragPile) {
              var noChildren = game.tarotUp.length === 0;
              if (dragPile.TAG === "Card") {
                return ;
              }
              var tarot = dragPile._0;
              if (noChildren && tarot.rank === "R0") {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        tarotUp: [tarot],
                        tarotDown: game.tarotDown,
                        free: game.free
                      };
              }
              
            }),
          autoProgress: true
        };
}

function tarotUpRules(tarot, j) {
  return {
          locationAdjustment: {
            x: Math.imul(10, j),
            y: 0,
            z: j
          },
          baseSpace: "TarotUp",
          dragPile: (function () {
              
            }),
          autoProgress: (function () {
              return "Seek";
            }),
          droppedUpon: (function (game, dragPile) {
              if (dragPile.TAG === "Card") {
                return ;
              }
              var dragTarot = dragPile._0;
              if (Tarot.rankIsBelow(tarot, dragTarot)) {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        tarotUp: game.tarotUp.concat([dragTarot]),
                        tarotDown: game.tarotDown,
                        free: game.free
                      };
              }
              
            }),
          applyMoveToOthers: (function (param) {
              
            })
        };
}

function tarotDownBaseRules() {
  return {
          droppedUpon: (function (game, dragPile) {
              var noChildren = game.tarotDown.length === 0;
              if (dragPile.TAG === "Card") {
                return ;
              }
              var tarot = dragPile._0;
              if (noChildren && tarot.rank === "R21") {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        tarotUp: game.tarotUp,
                        tarotDown: [tarot],
                        free: game.free
                      };
              }
              
            }),
          autoProgress: true
        };
}

function tarotDownRules(tarot, j) {
  return {
          locationAdjustment: {
            x: Math.imul(-10, j),
            y: 0,
            z: j
          },
          baseSpace: "TarotDown",
          dragPile: (function () {
              
            }),
          autoProgress: (function () {
              return "Seek";
            }),
          droppedUpon: (function (game, dragPile) {
              if (dragPile.TAG === "Card") {
                return ;
              }
              var dragTarot = dragPile._0;
              if (Tarot.rankIsAbove(tarot, dragTarot)) {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown.concat([dragTarot]),
                        free: game.free
                      };
              }
              
            }),
          applyMoveToOthers: (function (param) {
              
            })
        };
}

function freeBaseRules() {
  return {
          droppedUpon: (function (game, dragPile) {
              var match = game.free;
              if (match !== undefined) {
                return ;
              } else {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: dragPile
                      };
              }
            }),
          autoProgress: false
        };
}

function freeRules(card) {
  return {
          locationAdjustment: {
            x: 0,
            y: 0,
            z: 1
          },
          baseSpace: "Free",
          dragPile: (function () {
              return card;
            }),
          autoProgress: (function () {
              return {
                      TAG: "Send",
                      _0: card
                    };
            }),
          droppedUpon: (function (_game, _dragPile) {
              
            }),
          applyMoveToOthers: (function (param) {
              
            })
        };
}

function getRule(game, match) {
  var result = {
    contents: undefined
  };
  game.piles.forEach(function (pile, i) {
        if (Caml_obj.equal({
                TAG: "Pile",
                _0: i
              }, match)) {
          result.contents = {
            TAG: "Static",
            _0: pileBaseRules(i)
          };
        }
        pile.forEach(function (card, j) {
              if (Caml_obj.equal({
                      TAG: "Item",
                      _0: card
                    }, match)) {
                result.contents = {
                  TAG: "Movable",
                  _0: pileRules(pile, card, i, j)
                };
                return ;
              }
              
            });
      });
  game.foundations.forEach(function (foundation, i) {
        if (Caml_obj.equal({
                TAG: "Foundation",
                _0: i
              }, match)) {
          result.contents = {
            TAG: "Static",
            _0: foundationBaseRules(i)
          };
        }
        foundation.forEach(function (card, j) {
              if (Caml_obj.equal({
                      TAG: "Item",
                      _0: {
                        TAG: "Card",
                        _0: card
                      }
                    }, match)) {
                result.contents = {
                  TAG: "Movable",
                  _0: foundationRules(card, i, j)
                };
                return ;
              }
              
            });
      });
  if ("TarotUp" === match) {
    result.contents = {
      TAG: "Static",
      _0: tarotUpBaseRules()
    };
  }
  game.tarotUp.forEach(function (card, i) {
        if (Caml_obj.equal({
                TAG: "Item",
                _0: {
                  TAG: "Tarot",
                  _0: card
                }
              }, match)) {
          result.contents = {
            TAG: "Movable",
            _0: tarotUpRules(card, i)
          };
          return ;
        }
        
      });
  if ("TarotDown" === match) {
    result.contents = {
      TAG: "Static",
      _0: tarotDownBaseRules()
    };
  }
  game.tarotDown.forEach(function (card, i) {
        if (Caml_obj.equal({
                TAG: "Item",
                _0: {
                  TAG: "Tarot",
                  _0: card
                }
              }, match)) {
          result.contents = {
            TAG: "Movable",
            _0: tarotDownRules(card, i)
          };
          return ;
        }
        
      });
  if ("Free" === match) {
    result.contents = {
      TAG: "Static",
      _0: freeBaseRules()
    };
  }
  var free = game.free;
  if (free !== undefined && Caml_obj.equal({
          TAG: "Item",
          _0: free
        }, match)) {
    result.contents = {
      TAG: "Movable",
      _0: freeRules(free)
    };
  }
  return result.contents;
}

function UpAndDown$GameRules$Board(props) {
  var setRef = props.setRef;
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsxs("div", {
                              children: [
                                JsxRuntime.jsx("div", {
                                      children: "0",
                                      ref: Caml_option.some(setRef("TarotUp")),
                                      className: " border border-slate-300 bg-slate-200 rounded w-14 h-20 flex \n              flex-row items-center justify-center text-xl font-bold text-slate-400"
                                    }, JSON.stringify(space_encode("TarotUp"))),
                                JsxRuntime.jsx("div", {
                                      children: "21",
                                      ref: Caml_option.some(setRef("TarotDown")),
                                      className: " border border-slate-300 bg-slate-200 rounded w-14 h-20 flex \n              flex-row items-center justify-center text-xl font-bold text-slate-400"
                                    }, JSON.stringify(space_encode("TarotDown")))
                              ],
                              className: "flex flex-row justify-between",
                              style: {
                                width: "290px"
                              }
                            }),
                        JsxRuntime.jsx("div", {
                              ref: Caml_option.some(setRef("Free")),
                              className: "outline outline-2 outline-purple-300 bg-purple-100 rounded w-14 h-20 mx-10"
                            }, JSON.stringify(space_encode("Free"))),
                        JsxRuntime.jsx("div", {
                              children: [
                                  [],
                                  [],
                                  [],
                                  []
                                ].map(function (param, i) {
                                    return JsxRuntime.jsx("div", {
                                                ref: Caml_option.some(setRef({
                                                          TAG: "Foundation",
                                                          _0: i
                                                        })),
                                                className: " border  border-slate-200 bg-slate-100 rounded w-14 h-20"
                                              }, JSON.stringify(space_encode({
                                                        TAG: "Foundation",
                                                        _0: i
                                                      })));
                                  }),
                              className: "flex flex-row gap-3"
                            })
                      ],
                      className: "flex flex-row  "
                    }),
                JsxRuntime.jsx("div", {
                      children: [
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          []
                        ].map(function (param, i) {
                            return JsxRuntime.jsx("div", {
                                        ref: Caml_option.some(setRef({
                                                  TAG: "Pile",
                                                  _0: i
                                                })),
                                        className: " border border-slate-200 bg-slate-100  rounded w-14 h-20"
                                      }, JSON.stringify(space_encode({
                                                TAG: "Pile",
                                                _0: i
                                              })));
                          }),
                      className: "flex flex-row gap-3 mt-5"
                    })
              ]
            });
}

var Board = {
  make: UpAndDown$GameRules$Board
};

function UpAndDown$GameRules$AllCards(props) {
  var onMouseDown = props.onMouseDown;
  var setRef = props.setRef;
  return JsxRuntime.jsx(React.Fragment, {
              children: fullDeck.map(function (item) {
                    if (item.TAG === "Card") {
                      return JsxRuntime.jsx(Card.Display.make, {
                                  card: item._0,
                                  id: JSON.stringify(space_encode({
                                            TAG: "Item",
                                            _0: item
                                          })),
                                  cardRef: setRef({
                                        TAG: "Item",
                                        _0: item
                                      }),
                                  onMouseDown: onMouseDown,
                                  multiColor: true
                                }, JSON.stringify(space_encode({
                                          TAG: "Item",
                                          _0: item
                                        })));
                    } else {
                      return JsxRuntime.jsx(Tarot.Display.make, {
                                  card: item._0,
                                  id: JSON.stringify(space_encode({
                                            TAG: "Item",
                                            _0: item
                                          })),
                                  cardRef: setRef({
                                        TAG: "Item",
                                        _0: item
                                      }),
                                  onMouseDown: onMouseDown
                                }, JSON.stringify(space_encode({
                                          TAG: "Item",
                                          _0: item
                                        })));
                    }
                  })
            });
}

var AllCards = {
  make: UpAndDown$GameRules$AllCards
};

var GameRules = {
  getSpace: getSpace,
  spaceToString: spaceToString,
  initiateGame: initiateGame,
  getRule: getRule,
  removeDragFromGame: removeDragFromGame,
  winCheck: winCheck,
  Board: Board,
  AllCards: AllCards
};

var Game = GameBase.Create(GameRules);

export {
  GameRules ,
  Game ,
}
/* fullDeck Not a pure module */
