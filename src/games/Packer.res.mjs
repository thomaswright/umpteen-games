// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "../Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as React from "react";
import * as Common from "../Common.res.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as GameCommons from "./GameCommons.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function space_encode(value) {
  if (typeof value !== "object") {
    if (value === "Waste") {
      return ["Waste"];
    } else {
      return ["Stock"];
    }
  }
  switch (value.TAG) {
    case "Card" :
        return [
                "Card",
                Card.card_encode(value._0)
              ];
    case "Foundation" :
        return [
                "Foundation",
                Decco.intToJson(value._0)
              ];
    case "Pile" :
        return [
                "Pile",
                Decco.intToJson(value._0)
              ];
    case "Free" :
        return [
                "Free",
                Decco.intToJson(value._0)
              ];
    
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Free" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Free",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$3 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$3.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$3._0
                    }
                  };
          }
          var e$3 = v0$3._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$3.path,
                    message: e$3.message,
                    value: e$3.value
                  }
                };
      case "Stock" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Stock"
                  };
          }
      case "Waste" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Waste"
                  };
          }
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function game_encode(value) {
  return Js_dict.fromArray([
              [
                "piles",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.arrayToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.piles)
              ],
              [
                "foundations",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.arrayToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.foundations)
              ],
              [
                "stock",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.arrayToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.stock)
              ],
              [
                "waste",
                (function (extra) {
                      return Decco.arrayToJson(Card.sides_encode, extra);
                    })(value.waste)
              ],
              [
                "free",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.optionToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.free)
              ]
            ]);
}

function game_decode(value) {
  var dict = Js_json.classify(value);
  if (typeof dict !== "object") {
    return Decco.error(undefined, "Not an object", value);
  }
  if (dict.TAG !== "JSONObject") {
    return Decco.error(undefined, "Not an object", value);
  }
  var dict$1 = dict._0;
  var extra = Belt_Option.getWithDefault(Js_dict.get(dict$1, "piles"), null);
  var piles = Decco.arrayFromJson((function (extra) {
          return Decco.arrayFromJson(Card.sides_decode, extra);
        }), extra);
  if (piles.TAG === "Ok") {
    var extra$1 = Belt_Option.getWithDefault(Js_dict.get(dict$1, "foundations"), null);
    var foundations = Decco.arrayFromJson((function (extra) {
            return Decco.arrayFromJson(Card.sides_decode, extra);
          }), extra$1);
    if (foundations.TAG === "Ok") {
      var extra$2 = Belt_Option.getWithDefault(Js_dict.get(dict$1, "stock"), null);
      var stock = Decco.arrayFromJson((function (extra) {
              return Decco.arrayFromJson(Card.sides_decode, extra);
            }), extra$2);
      if (stock.TAG === "Ok") {
        var extra$3 = Belt_Option.getWithDefault(Js_dict.get(dict$1, "waste"), null);
        var waste = Decco.arrayFromJson(Card.sides_decode, extra$3);
        if (waste.TAG === "Ok") {
          var extra$4 = Belt_Option.getWithDefault(Js_dict.get(dict$1, "free"), null);
          var free = Decco.arrayFromJson((function (extra) {
                  return Decco.optionFromJson(Card.sides_decode, extra);
                }), extra$4);
          if (free.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: Decco.unsafeAddFieldToObject("piles", piles._0, Decco.unsafeAddFieldToObject("foundations", foundations._0, Decco.unsafeAddFieldToObject("stock", stock._0, Decco.unsafeAddFieldToObject("waste", waste._0, Decco.unsafeAddFieldToObject("free", free._0, {})))))
                  };
          }
          var e = free._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: ".free" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
        }
        var e$1 = waste._0;
        return {
                TAG: "Error",
                _0: {
                  path: ".waste" + e$1.path,
                  message: e$1.message,
                  value: e$1.value
                }
              };
      }
      var e$2 = stock._0;
      return {
              TAG: "Error",
              _0: {
                path: ".stock" + e$2.path,
                message: e$2.message,
                value: e$2.value
              }
            };
    }
    var e$3 = foundations._0;
    return {
            TAG: "Error",
            _0: {
              path: ".foundations" + e$3.path,
              message: e$3.message,
              value: e$3.value
            }
          };
  }
  var e$4 = piles._0;
  return {
          TAG: "Error",
          _0: {
            path: ".piles" + e$4.path,
            message: e$4.message,
            value: e$4.value
          }
        };
}

function onlyFoundationWinCheck(game) {
  if (game.piles.every(function (pile) {
          return pile.length === 0;
        }) && game.free.every(Core__Option.isNone) && game.stock.length === 0) {
    return game.waste.length === 0;
  } else {
    return false;
  }
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

function Make(PackerRules) {
  var game_encode$1 = function (value) {
    return game_encode(value);
  };
  var game_decode$1 = function (value) {
    return game_decode(value);
  };
  var deck_encode = function (value) {
    return Decco.arrayToJson(Card.sides_encode, value);
  };
  var deck_decode = function (value) {
    return Decco.arrayFromJson(Card.sides_decode, value);
  };
  var dropCheck = function (isLast, dragPile, card) {
    var dragPileBase = dragPile[0];
    var match = PackerRules.spec.drop;
    switch (match) {
      case "AltSuit" :
          if (isLast && Card.rankIsAbove(card, dragPileBase)) {
            return Card.color(dragPileBase) !== Card.color(card);
          } else {
            return false;
          }
      case "AnySuit" :
          if (isLast) {
            return Card.rankIsAbove(card, dragPileBase);
          } else {
            return false;
          }
      case "OneSuit" :
          if (isLast && Card.rankIsAbove(card, dragPileBase)) {
            return dragPileBase.card.suit === card.card.suit;
          } else {
            return false;
          }
      case "CyclicOneSuit" :
          if (isLast && Card.rankIsAboveCyclic(card, dragPileBase)) {
            return dragPileBase.card.suit === card.card.suit;
          } else {
            return false;
          }
      case "CyclicAnySuit" :
          if (isLast) {
            return Card.rankIsAboveCyclic(card, dragPileBase);
          } else {
            return false;
          }
      case "CyclicSameColor" :
          if (isLast && Card.rankIsAboveCyclic(card, dragPileBase)) {
            return Card.color(dragPileBase) === Card.color(card);
          } else {
            return false;
          }
      case "NoDrop" :
          return false;
      
    }
  };
  var dragCheck = function (dragPile) {
    var match = PackerRules.spec.drag;
    switch (match) {
      case "AltSuit" :
          return GameCommons.decAltColorValidation(dragPile);
      case "AnySuit" :
          return true;
      case "OneSuit" :
          return GameCommons.decOneSuitValidation(dragPile);
      case "CyclicOneSuit" :
          return GameCommons.decCyclicOneSuitValidation(dragPile);
      case "CyclicAnySuit" :
          return GameCommons.decCyclicAnySuitValidation(dragPile);
      case "CyclicSameColor" :
          return GameCommons.decCyclicSameColorValidation(dragPile);
      case "NoDrop" :
          return false;
      
    }
  };
  var dragSizeCheck = function (game, dragPile) {
    var freeCellCount = game.piles.filter(function (pile) {
          return pile.length === 0;
        }).length + game.free.filter(Core__Option.isNone).length | 0;
    var match = PackerRules.spec.size;
    switch (match) {
      case "AnySize" :
          return true;
      case "FreeSize" :
          return freeCellCount >= (dragPile.length - 1 | 0);
      case "JustOne" :
          return dragPile.length === 1;
      
    }
  };
  var pileBaseCheck = function (game, dragPile, i) {
    var dragPileBase = dragPile[0];
    var noChildren = game.piles[i].length === 0;
    var rank = PackerRules.spec.depot;
    if (typeof rank !== "object") {
      return noChildren;
    } else if (noChildren) {
      return dragPileBase.card.rank === rank._0;
    } else {
      return false;
    }
  };
  var foundationBaseCheck = function (game, dragPile, i) {
    var justOne = dragPile.length === 1;
    var fullStack = dragPile.length === 13;
    var noChildren = game.foundations[i].length === 0;
    var valid = GameCommons.decOneSuitValidation(dragPile);
    var dragPileBase = dragPile[0];
    var match = PackerRules.spec.foundation;
    switch (match) {
      case "ByAll" :
          if (noChildren && fullStack) {
            return valid;
          } else {
            return false;
          }
      case "NoFoundation" :
          return false;
      default:
        if (noChildren && justOne) {
          return dragPileBase.card.rank === "RA";
        } else {
          return false;
        }
    }
  };
  var foundationCheck = function (dragPile, card) {
    var justOne = dragPile.length === 1;
    var dragPileBase = dragPile[0];
    var match = PackerRules.spec.foundation;
    switch (match) {
      case "ByOne" :
          if (justOne && dragPileBase.card.suit === card.card.suit) {
            return Card.rankIsAbove(dragPileBase, card);
          } else {
            return false;
          }
      case "ByOneCyclicOneSuit" :
          if (justOne && dragPileBase.card.suit === card.card.suit) {
            return Card.rankIsAboveCyclic(dragPileBase, card);
          } else {
            return false;
          }
      case "ByOneCyclicAnySuit" :
          if (justOne) {
            return Card.rankIsAboveCyclic(dragPileBase, card);
          } else {
            return false;
          }
      case "ByAll" :
      case "NoFoundation" :
          return false;
      
    }
  };
  var applyLiftToDragPile = function (dragPile, lift) {
    dragPile.forEach(function (v, j) {
          lift({
                TAG: "Card",
                _0: v.card
              }, j);
        });
  };
  var applyMoveToDragPile = function (dragPile, move) {
    dragPile.forEach(function (v, j) {
          move({
                TAG: "Card",
                _0: v.card
              }, 0, Math.imul(j, 20));
        });
  };
  var removeDragFromGame = function (game, dragPile) {
    var dragPileSet = new Set(dragPile);
    var removeDragPile = function (x) {
      return x.filter(function (sCard) {
                  return !dragPileSet.has(sCard);
                });
    };
    return {
            piles: game.piles.map(removeDragPile),
            foundations: game.foundations.map(removeDragPile),
            stock: game.stock.map(removeDragPile),
            waste: removeDragPile(game.waste),
            free: game.free.map(function (card) {
                  return Core__Option.flatMap(card, (function (card) {
                                if (dragPile.some(function (dCard) {
                                        return Caml_obj.equal(card, dCard);
                                      })) {
                                  return ;
                                } else {
                                  return card;
                                }
                              }));
                })
          };
  };
  var pileBaseRules = function (game, i) {
    return {
            droppedUpon: (function (gameRemoved, dragPile) {
                if (pileBaseCheck(game, dragPile, i)) {
                  return {
                          piles: GameCommons.flipLastUp(Common.ArrayAux.update(gameRemoved.piles, i, (function (param) {
                                      return dragPile;
                                    }))),
                          foundations: gameRemoved.foundations,
                          stock: gameRemoved.stock,
                          waste: gameRemoved.waste,
                          free: gameRemoved.free
                        };
                }
                
              }),
            autoProgress: "Accept",
            onClick: (function (param) {
                
              })
          };
  };
  var pileRules = function (game, pile, card, i, j) {
    var isLast = j === (pile.length - 1 | 0);
    return {
            locationAdjustment: {
              x: 0,
              y: Math.imul(j, 20),
              z: j + 1 | 0
            },
            baseSpace: {
              TAG: "Pile",
              _0: i
            },
            dragPile: (function () {
                var dragPile = pile.slice(j);
                if (dragCheck(dragPile) && dragSizeCheck(game, dragPile)) {
                  return dragPile;
                }
                
              }),
            autoProgress: (function () {
                if (isLast) {
                  return {
                          TAG: "SendOrAccept",
                          _0: [card]
                        };
                } else {
                  return "DoNothing";
                }
              }),
            droppedUpon: (function (game, dragPile) {
                if (dropCheck(isLast, dragPile, card)) {
                  return {
                          piles: GameCommons.flipLastUp(game.piles.map(function (stack) {
                                    return Common.ArrayAux.insertAfter(stack, card, dragPile);
                                  })),
                          foundations: game.foundations,
                          stock: game.stock,
                          waste: game.waste,
                          free: game.free
                        };
                }
                
              }),
            onStateChange: (function (element) {
                Card.showOrHide(card, element);
              }),
            onClick: (function (param) {
                
              })
          };
  };
  var foundationBaseRules = function (i) {
    return {
            droppedUpon: (function (game, dragPile) {
                if (foundationBaseCheck(game, dragPile, i)) {
                  return {
                          piles: GameCommons.flipLastUp(game.piles),
                          foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                  return dragPile;
                                })),
                          stock: game.stock,
                          waste: game.waste,
                          free: game.free
                        };
                }
                
              }),
            autoProgress: "Seek",
            onClick: (function (param) {
                
              })
          };
  };
  var foundationRules = function (game, pile, card, i, j) {
    var isLast = j === (pile.length - 1 | 0);
    return {
            locationAdjustment: {
              x: 0,
              y: 0,
              z: j + 1 | 0
            },
            baseSpace: {
              TAG: "Foundation",
              _0: i
            },
            dragPile: (function () {
                if (j === (game.foundations.length - 1 | 0)) {
                  return [card];
                }
                
              }),
            autoProgress: (function () {
                return "Seek";
              }),
            droppedUpon: (function (game, dragPile) {
                if (isLast && foundationCheck(dragPile, card)) {
                  return {
                          piles: GameCommons.flipLastUp(game.piles),
                          foundations: game.foundations.map(function (stack) {
                                return Common.ArrayAux.insertAfter(stack, card, dragPile);
                              }),
                          stock: game.stock,
                          waste: game.waste,
                          free: game.free
                        };
                }
                
              }),
            onStateChange: (function (element) {
                Card.showOrHide(card, element);
              }),
            onClick: (function (param) {
                
              })
          };
  };
  var wasteRules = function (_game, _card, i) {
    return {
            locationAdjustment: {
              x: Math.imul(20, i),
              y: 0,
              z: i + 1 | 0
            },
            baseSpace: "Waste",
            dragPile: (function () {
                
              }),
            autoProgress: (function () {
                return "DoNothing";
              }),
            droppedUpon: (function (param, param$1) {
                
              }),
            onStateChange: (function (param) {
                
              }),
            onClick: (function (param) {
                
              })
          };
  };
  var stockRules = function (_game, _card, _i, j) {
    return {
            locationAdjustment: {
              x: 0,
              y: 0,
              z: j + 1 | 0
            },
            baseSpace: "Stock",
            dragPile: (function () {
                
              }),
            autoProgress: (function () {
                return "DoNothing";
              }),
            droppedUpon: (function (param, param$1) {
                
              }),
            onStateChange: (function (param) {
                
              }),
            onClick: (function (param) {
                
              })
          };
  };
  var stockBaseRules = function () {
    return {
            droppedUpon: (function (param, param$1) {
                
              }),
            autoProgress: "DoNothing",
            onClick: (function (param) {
                
              })
          };
  };
  var freeRules = function (_card, i) {
    return {
            locationAdjustment: {
              x: 0,
              y: 0,
              z: i + 1 | 0
            },
            baseSpace: "Stock",
            dragPile: (function () {
                
              }),
            autoProgress: (function () {
                return "DoNothing";
              }),
            droppedUpon: (function (param, param$1) {
                
              }),
            onStateChange: (function (param) {
                
              }),
            onClick: (function (param) {
                
              })
          };
  };
  var freeBaseRules = function (param) {
    return {
            droppedUpon: (function (param, param$1) {
                
              }),
            autoProgress: "DoNothing",
            onClick: (function (param) {
                
              })
          };
  };
  var makeForEachSpace = function (pileBaseRulesOpt, pileRulesOpt, foundationBaseRulesOpt, foundationRulesOpt, wasteRulesOpt, stockBaseRulesOpt, stockRulesOpt, freeBaseRulesOpt, freeRulesOpt) {
    var pileBaseRules$1 = pileBaseRulesOpt !== undefined ? pileBaseRulesOpt : pileBaseRules;
    var pileRules$1 = pileRulesOpt !== undefined ? pileRulesOpt : pileRules;
    var foundationBaseRules$1 = foundationBaseRulesOpt !== undefined ? foundationBaseRulesOpt : foundationBaseRules;
    var foundationRules$1 = foundationRulesOpt !== undefined ? foundationRulesOpt : foundationRules;
    var wasteRules$1 = wasteRulesOpt !== undefined ? wasteRulesOpt : wasteRules;
    var stockBaseRules$1 = stockBaseRulesOpt !== undefined ? stockBaseRulesOpt : stockBaseRules;
    var stockRules$1 = stockRulesOpt !== undefined ? stockRulesOpt : stockRules;
    var freeBaseRules$1 = freeBaseRulesOpt !== undefined ? freeBaseRulesOpt : freeBaseRules;
    var freeRules$1 = freeRulesOpt !== undefined ? freeRulesOpt : freeRules;
    return function (game, f) {
      game.piles.forEach(function (pile, i) {
            f({
                  TAG: "Pile",
                  _0: i
                }, {
                  TAG: "Static",
                  _0: pileBaseRules$1(game, i)
                });
            pile.forEach(function (card, j) {
                  f({
                        TAG: "Card",
                        _0: card.card
                      }, {
                        TAG: "Movable",
                        _0: pileRules$1(game, pile, card, i, j)
                      });
                });
          });
      game.foundations.forEach(function (foundation, i) {
            f({
                  TAG: "Foundation",
                  _0: i
                }, {
                  TAG: "Static",
                  _0: foundationBaseRules$1(i)
                });
            foundation.forEach(function (card, j) {
                  f({
                        TAG: "Card",
                        _0: card.card
                      }, {
                        TAG: "Movable",
                        _0: foundationRules$1(game, foundation, card, i, j)
                      });
                });
          });
      game.waste.forEach(function (card, i) {
            f({
                  TAG: "Card",
                  _0: card.card
                }, {
                  TAG: "Movable",
                  _0: wasteRules$1(game, card, i)
                });
          });
      game.stock.forEach(function (group, i) {
            group.forEach(function (card, j) {
                  f({
                        TAG: "Card",
                        _0: card.card
                      }, {
                        TAG: "Movable",
                        _0: stockRules$1(game, card, i, j)
                      });
                });
          });
      f("Stock", {
            TAG: "Static",
            _0: stockBaseRules$1()
          });
      game.free.forEach(function (card, i) {
            f({
                  TAG: "Free",
                  _0: i
                }, {
                  TAG: "Static",
                  _0: freeBaseRules$1(i)
                });
            Core__Option.mapOr(card, undefined, (function (card) {
                    f({
                          TAG: "Card",
                          _0: card.card
                        }, {
                          TAG: "Movable",
                          _0: freeRules$1(card, i)
                        });
                  }));
          });
    };
  };
  var Packer$Make$AllCards = function (props) {
    var onMouseDown = props.onMouseDown;
    var setRef = props.setRef;
    return JsxRuntime.jsx(React.Fragment, {
                children: props.deck.map(function (card) {
                      return JsxRuntime.jsx(Card.Display.make, {
                                  card: card,
                                  id: JSON.stringify(space_encode({
                                            TAG: "Card",
                                            _0: card.card
                                          })),
                                  cardRef: setRef({
                                        TAG: "Card",
                                        _0: card.card
                                      }),
                                  onMouseDown: onMouseDown
                                }, JSON.stringify(space_encode({
                                          TAG: "Card",
                                          _0: card.card
                                        })));
                    })
              });
  };
  var AllCards = {
    make: Packer$Make$AllCards
  };
  return {
          game_encode: game_encode$1,
          game_decode: game_decode$1,
          getSpace: getSpace,
          spaceToString: spaceToString,
          deck_encode: deck_encode,
          deck_decode: deck_decode,
          winCheck: onlyFoundationWinCheck,
          dropCheck: dropCheck,
          dragCheck: dragCheck,
          dragSizeCheck: dragSizeCheck,
          pileBaseCheck: pileBaseCheck,
          foundationBaseCheck: foundationBaseCheck,
          foundationCheck: foundationCheck,
          applyLiftToDragPile: applyLiftToDragPile,
          applyMoveToDragPile: applyMoveToDragPile,
          removeDragFromGame: removeDragFromGame,
          pileBaseRules: pileBaseRules,
          pileRules: pileRules,
          foundationBaseRules: foundationBaseRules,
          foundationRules: foundationRules,
          wasteRules: wasteRules,
          stockRules: stockRules,
          stockBaseRules: stockBaseRules,
          freeRules: freeRules,
          freeBaseRules: freeBaseRules,
          makeForEachSpace: makeForEachSpace,
          AllCards: AllCards
        };
}

export {
  space_encode ,
  space_decode ,
  game_encode ,
  game_decode ,
  onlyFoundationWinCheck ,
  getSpace ,
  spaceToString ,
  Make ,
}
/* Card Not a pure module */
