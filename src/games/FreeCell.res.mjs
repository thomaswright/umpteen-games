// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "../Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as React from "react";
import * as Common from "../Common.res.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as GameBase from "../GameBase.res.mjs";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as GameCommons from "./GameCommons.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function space_encode(value) {
  switch (value.TAG) {
    case "Card" :
        return [
                "Card",
                Card.card_encode(value._0)
              ];
    case "Foundation" :
        return [
                "Foundation",
                Decco.intToJson(value._0)
              ];
    case "Pile" :
        return [
                "Pile",
                Decco.intToJson(value._0)
              ];
    case "Free" :
        return [
                "Free",
                Decco.intToJson(value._0)
              ];
    
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Free" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Free",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$3 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$3.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$3._0
                    }
                  };
          }
          var e$3 = v0$3._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$3.path,
                    message: e$3.message,
                    value: e$3.value
                  }
                };
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

function deck_encode(value) {
  return Decco.arrayToJson(Card.sides_encode, value);
}

function deck_decode(value) {
  return Decco.arrayFromJson(Card.sides_decode, value);
}

function game_encode(value) {
  return Js_dict.fromArray([
              [
                "piles",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.arrayToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.piles)
              ],
              [
                "foundations",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.arrayToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.foundations)
              ],
              [
                "free",
                (function (extra) {
                      return Decco.arrayToJson((function (extra) {
                                    return Decco.optionToJson(Card.sides_encode, extra);
                                  }), extra);
                    })(value.free)
              ]
            ]);
}

function game_decode(value) {
  var dict = Js_json.classify(value);
  if (typeof dict !== "object") {
    return Decco.error(undefined, "Not an object", value);
  }
  if (dict.TAG !== "JSONObject") {
    return Decco.error(undefined, "Not an object", value);
  }
  var dict$1 = dict._0;
  var extra = Belt_Option.getWithDefault(Js_dict.get(dict$1, "piles"), null);
  var piles = Decco.arrayFromJson((function (extra) {
          return Decco.arrayFromJson(Card.sides_decode, extra);
        }), extra);
  if (piles.TAG === "Ok") {
    var extra$1 = Belt_Option.getWithDefault(Js_dict.get(dict$1, "foundations"), null);
    var foundations = Decco.arrayFromJson((function (extra) {
            return Decco.arrayFromJson(Card.sides_decode, extra);
          }), extra$1);
    if (foundations.TAG === "Ok") {
      var extra$2 = Belt_Option.getWithDefault(Js_dict.get(dict$1, "free"), null);
      var free = Decco.arrayFromJson((function (extra) {
              return Decco.optionFromJson(Card.sides_decode, extra);
            }), extra$2);
      if (free.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: Decco.unsafeAddFieldToObject("piles", piles._0, Decco.unsafeAddFieldToObject("foundations", foundations._0, Decco.unsafeAddFieldToObject("free", free._0, {})))
              };
      }
      var e = free._0;
      return {
              TAG: "Error",
              _0: {
                path: ".free" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = foundations._0;
    return {
            TAG: "Error",
            _0: {
              path: ".foundations" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = piles._0;
  return {
          TAG: "Error",
          _0: {
            path: ".piles" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
}

function initiateGame() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  return [
          shuffledDeck,
          {
            piles: [
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6)
            ],
            foundations: [
              [],
              [],
              [],
              []
            ],
            free: [
              undefined,
              undefined,
              undefined,
              undefined
            ]
          }
        ];
}

function winCheck(game) {
  if (game.piles.every(function (pile) {
          return pile.length === 0;
        })) {
    return game.free.every(Core__Option.isNone);
  } else {
    return false;
  }
}

function removeDragFromGame(game, dragPile) {
  var dragPileSet = new Set(dragPile);
  var removeDragPile = function (x) {
    return x.filter(function (sCard) {
                return !dragPileSet.has(sCard);
              });
  };
  return {
          piles: game.piles.map(removeDragPile),
          foundations: game.foundations.map(removeDragPile),
          free: game.free.map(function (card) {
                return Core__Option.flatMap(card, (function (card) {
                              if (dragPile.some(function (dCard) {
                                      return Caml_obj.equal(card, dCard);
                                    })) {
                                return ;
                              } else {
                                return card;
                              }
                            }));
              })
        };
}

function applyLiftToDragPile(dragPile, lift) {
  dragPile.forEach(function (v, j) {
        lift({
              TAG: "Card",
              _0: v.card
            }, j);
      });
}

function applyMoveToDragPile(dragPile, move) {
  dragPile.forEach(function (v, j) {
        move({
              TAG: "Card",
              _0: v.card
            }, 0, Math.imul(j, 20));
      });
}

function pileBaseRules(game, i) {
  return {
          droppedUpon: (function (gameRemoved, dragPile) {
              var noChildren = game.piles[i].length === 0;
              if (noChildren) {
                return {
                        piles: Common.ArrayAux.update(gameRemoved.piles, i, (function (param) {
                                return dragPile;
                              })),
                        foundations: gameRemoved.foundations,
                        free: gameRemoved.free
                      };
              }
              
            }),
          autoProgress: "Accept",
          onClick: (function (param) {
              
            })
        };
}

function pileRules(game, pile, card, i, j) {
  var isLast = j === (pile.length - 1 | 0);
  return {
          locationAdjustment: {
            x: 0,
            y: Math.imul(j, 20),
            z: j + 1 | 0
          },
          baseSpace: {
            TAG: "Pile",
            _0: i
          },
          dragPile: (function () {
              var freeCellCount = game.piles.filter(function (pile) {
                    return pile.length === 0;
                  }).length + game.free.filter(Core__Option.isNone).length | 0;
              var dragPile = pile.slice(j);
              if (GameCommons.decAndAltValidation(dragPile) && freeCellCount >= (dragPile.length - 1 | 0)) {
                return dragPile;
              }
              
            }),
          autoProgress: (function () {
              if (isLast) {
                return {
                        TAG: "SendOrAccept",
                        _0: [card]
                      };
              } else {
                return "DoNothing";
              }
            }),
          droppedUpon: (function (game, dragPile) {
              var dragPileBase = dragPile[0];
              if (isLast && Card.rankIsAbove(card, dragPileBase) && Card.color(dragPileBase) !== Card.color(card)) {
                return {
                        piles: game.piles.map(function (stack) {
                              return Common.ArrayAux.insertAfter(stack, card, dragPile);
                            }),
                        foundations: game.foundations,
                        free: game.free
                      };
              }
              
            }),
          onStateChange: (function (param) {
              
            }),
          onClick: (function (param) {
              
            })
        };
}

function foundationBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              var justOne = dragPile.length === 1;
              var dragPileBase = dragPile[0];
              var noChildren = game.foundations[i].length === 0;
              if (noChildren && justOne && dragPileBase.card.rank === "RA") {
                return {
                        piles: game.piles,
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                return dragPile;
                              })),
                        free: game.free
                      };
              }
              
            }),
          autoProgress: "Seek",
          onClick: (function (param) {
              
            })
        };
}

function foundationRules(game, foundation, card, i, j) {
  var isLast = j === (foundation.length - 1 | 0);
  return {
          locationAdjustment: {
            x: 0,
            y: 0,
            z: j + 1 | 0
          },
          baseSpace: {
            TAG: "Foundation",
            _0: i
          },
          dragPile: (function () {
              if (j === (game.foundations.length - 1 | 0)) {
                return [card];
              }
              
            }),
          autoProgress: (function () {
              return "Seek";
            }),
          droppedUpon: (function (game, dragPile) {
              var justOne = dragPile.length === 1;
              var dragPileBase = dragPile[0];
              if (isLast && justOne && dragPileBase.card.suit === card.card.suit && Card.rankIsBelow(card, dragPileBase)) {
                return {
                        piles: game.piles,
                        foundations: game.foundations.map(function (stack) {
                              return Common.ArrayAux.insertAfter(stack, card, dragPile);
                            }),
                        free: game.free
                      };
              }
              
            }),
          onStateChange: (function (param) {
              
            }),
          onClick: (function (param) {
              
            })
        };
}

function freeBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              var noChildren = Core__Option.isNone(game.free[i]);
              if (noChildren && dragPile.length === 1) {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        free: Common.ArrayAux.update(game.free, i, (function (param) {
                                return dragPile[0];
                              }))
                      };
              }
              
            }),
          autoProgress: "DoNothing",
          onClick: (function (param) {
              
            })
        };
}

function freeRules(card, i) {
  return {
          locationAdjustment: {
            x: 0,
            y: 0,
            z: 1
          },
          baseSpace: {
            TAG: "Free",
            _0: i
          },
          dragPile: (function () {
              return [card];
            }),
          autoProgress: (function () {
              return {
                      TAG: "Send",
                      _0: [card]
                    };
            }),
          droppedUpon: (function (_game, _dragPile) {
              
            }),
          onStateChange: (function (param) {
              
            }),
          onClick: (function (param) {
              
            })
        };
}

function forEachSpace(game, f) {
  game.piles.forEach(function (pile, i) {
        f({
              TAG: "Pile",
              _0: i
            }, {
              TAG: "Static",
              _0: pileBaseRules(game, i)
            });
        pile.forEach(function (card, j) {
              f({
                    TAG: "Card",
                    _0: card.card
                  }, {
                    TAG: "Movable",
                    _0: pileRules(game, pile, card, i, j)
                  });
            });
      });
  game.foundations.forEach(function (foundation, i) {
        f({
              TAG: "Foundation",
              _0: i
            }, {
              TAG: "Static",
              _0: foundationBaseRules(i)
            });
        foundation.forEach(function (card, j) {
              f({
                    TAG: "Card",
                    _0: card.card
                  }, {
                    TAG: "Movable",
                    _0: foundationRules(game, foundation, card, i, j)
                  });
            });
      });
  game.free.forEach(function (card, i) {
        f({
              TAG: "Free",
              _0: i
            }, {
              TAG: "Static",
              _0: freeBaseRules(i)
            });
        Core__Option.mapOr(card, undefined, (function (card) {
                f({
                      TAG: "Card",
                      _0: card.card
                    }, {
                      TAG: "Movable",
                      _0: freeRules(card, i)
                    });
              }));
      });
}

function FreeCell$FreeCellRules$AllCards(props) {
  var onMouseDown = props.onMouseDown;
  var setRef = props.setRef;
  return JsxRuntime.jsx(React.Fragment, {
              children: props.deck.map(function (card) {
                    return JsxRuntime.jsx(Card.Display.make, {
                                card: card,
                                id: JSON.stringify(space_encode({
                                          TAG: "Card",
                                          _0: card.card
                                        })),
                                cardRef: setRef({
                                      TAG: "Card",
                                      _0: card.card
                                    }),
                                onMouseDown: onMouseDown
                              }, JSON.stringify(space_encode({
                                        TAG: "Card",
                                        _0: card.card
                                      })));
                  })
            });
}

var AllCards = {
  make: FreeCell$FreeCellRules$AllCards
};

function FreeCell$FreeCellRules$StandardBoard(props) {
  var setRef = props.setRef;
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsx("div", {
                              children: [
                                  [],
                                  [],
                                  [],
                                  []
                                ].map(function (param, i) {
                                    return JsxRuntime.jsx("div", {
                                                ref: Caml_option.some(setRef({
                                                          TAG: "Free",
                                                          _0: i
                                                        })),
                                                className: " bg-black opacity-20   rounded w-14 h-20"
                                              }, JSON.stringify(space_encode({
                                                        TAG: "Free",
                                                        _0: i
                                                      })));
                                  }),
                              className: "flex flex-row gap-3"
                            }),
                        JsxRuntime.jsx("div", {
                              children: [
                                  [],
                                  [],
                                  [],
                                  []
                                ].map(function (param, i) {
                                    return JsxRuntime.jsx("div", {
                                                ref: Caml_option.some(setRef({
                                                          TAG: "Foundation",
                                                          _0: i
                                                        })),
                                                className: " bg-white opacity-10  rounded w-14 h-20"
                                              }, JSON.stringify(space_encode({
                                                        TAG: "Foundation",
                                                        _0: i
                                                      })));
                                  }),
                              className: "flex flex-row gap-3 ml-10"
                            })
                      ],
                      className: "flex flex-row"
                    }),
                JsxRuntime.jsx("div", {}),
                JsxRuntime.jsx("div", {
                      children: [
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          []
                        ].map(function (param, i) {
                            return JsxRuntime.jsx("div", {
                                        ref: Caml_option.some(setRef({
                                                  TAG: "Pile",
                                                  _0: i
                                                })),
                                        className: " bg-black opacity-20   rounded w-14 h-20"
                                      }, JSON.stringify(space_encode({
                                                TAG: "Pile",
                                                _0: i
                                              })));
                          }),
                      className: "flex flex-row gap-3 mt-5"
                    })
              ]
            });
}

var StandardBoard = {
  make: FreeCell$FreeCellRules$StandardBoard
};

var FreeCellRules = {
  space_encode: space_encode,
  space_decode: space_decode,
  getSpace: getSpace,
  spaceToString: spaceToString,
  deck_encode: deck_encode,
  deck_decode: deck_decode,
  game_encode: game_encode,
  game_decode: game_decode,
  initiateGame: initiateGame,
  winCheck: winCheck,
  removeDragFromGame: removeDragFromGame,
  applyLiftToDragPile: applyLiftToDragPile,
  applyMoveToDragPile: applyMoveToDragPile,
  pileBaseRules: pileBaseRules,
  pileRules: pileRules,
  foundationBaseRules: foundationBaseRules,
  foundationRules: foundationRules,
  freeBaseRules: freeBaseRules,
  freeRules: freeRules,
  forEachSpace: forEachSpace,
  AllCards: AllCards,
  StandardBoard: StandardBoard
};

var OneDeck = GameBase.Create({
      game_encode: game_encode,
      game_decode: game_decode,
      deck_encode: deck_encode,
      deck_decode: deck_decode,
      getSpace: getSpace,
      spaceToString: spaceToString,
      initiateGame: initiateGame,
      forEachSpace: forEachSpace,
      removeDragFromGame: removeDragFromGame,
      winCheck: winCheck,
      applyLiftToDragPile: applyLiftToDragPile,
      applyMoveToDragPile: applyMoveToDragPile,
      Board: StandardBoard,
      AllCards: AllCards
    });

function FreeCell$TwoDeck$Board(props) {
  var setRef = props.setRef;
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsxs("div", {
                              children: [
                                JsxRuntime.jsx("div", {
                                      children: [
                                          [],
                                          [],
                                          [],
                                          []
                                        ].map(function (param, i) {
                                            return JsxRuntime.jsx("div", {
                                                        ref: Caml_option.some(setRef({
                                                                  TAG: "Free",
                                                                  _0: i
                                                                })),
                                                        className: "   bg-black opacity-20  rounded w-14 h-20"
                                                      }, JSON.stringify(space_encode({
                                                                TAG: "Free",
                                                                _0: i
                                                              })));
                                          }),
                                      className: "flex flex-row gap-3"
                                    }),
                                JsxRuntime.jsx("div", {
                                      children: [
                                          [],
                                          [],
                                          [],
                                          []
                                        ].map(function (param, i) {
                                            return JsxRuntime.jsx("div", {
                                                        ref: Caml_option.some(setRef({
                                                                  TAG: "Free",
                                                                  _0: i + 4 | 0
                                                                })),
                                                        className: "   bg-black opacity-20  rounded w-14 h-20"
                                                      }, JSON.stringify(space_encode({
                                                                TAG: "Free",
                                                                _0: i + 4 | 0
                                                              })));
                                          }),
                                      className: "flex flex-row gap-3"
                                    })
                              ],
                              className: "flex flex-col gap-3"
                            }),
                        JsxRuntime.jsxs("div", {
                              children: [
                                JsxRuntime.jsx("div", {
                                      children: [
                                          [],
                                          [],
                                          [],
                                          []
                                        ].map(function (param, i) {
                                            return JsxRuntime.jsx("div", {
                                                        ref: Caml_option.some(setRef({
                                                                  TAG: "Foundation",
                                                                  _0: i
                                                                })),
                                                        className: "   bg-white opacity-10  rounded w-14 h-20"
                                                      }, JSON.stringify(space_encode({
                                                                TAG: "Free",
                                                                _0: i
                                                              })));
                                          }),
                                      className: "flex flex-row gap-3 ml-10"
                                    }),
                                JsxRuntime.jsx("div", {
                                      children: [
                                          [],
                                          [],
                                          [],
                                          []
                                        ].map(function (param, i) {
                                            return JsxRuntime.jsx("div", {
                                                        ref: Caml_option.some(setRef({
                                                                  TAG: "Foundation",
                                                                  _0: i + 4 | 0
                                                                })),
                                                        className: "   bg-white opacity-10  rounded w-14 h-20"
                                                      }, JSON.stringify(space_encode({
                                                                TAG: "Free",
                                                                _0: i + 4 | 0
                                                              })));
                                          }),
                                      className: "flex flex-row gap-3 ml-10"
                                    })
                              ],
                              className: "flex flex-col gap-3"
                            })
                      ],
                      className: "flex flex-row"
                    }),
                JsxRuntime.jsx("div", {}),
                JsxRuntime.jsx("div", {
                      children: [
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          []
                        ].map(function (param, i) {
                            return JsxRuntime.jsx("div", {
                                        ref: Caml_option.some(setRef({
                                                  TAG: "Pile",
                                                  _0: i
                                                })),
                                        className: " bg-black opacity-20  rounded w-14 h-20"
                                      }, JSON.stringify(space_encode({
                                                TAG: "Pile",
                                                _0: i
                                              })));
                          }),
                      className: "flex flex-row gap-3 mt-5"
                    })
              ]
            });
}

var Board = {
  make: FreeCell$TwoDeck$Board
};

var TwoDeck = GameBase.Create({
      game_encode: game_encode,
      game_decode: game_decode,
      deck_encode: deck_encode,
      deck_decode: deck_decode,
      getSpace: getSpace,
      spaceToString: spaceToString,
      initiateGame: initiateGame,
      forEachSpace: forEachSpace,
      removeDragFromGame: removeDragFromGame,
      winCheck: winCheck,
      applyLiftToDragPile: applyLiftToDragPile,
      applyMoveToDragPile: applyMoveToDragPile,
      Board: Board,
      AllCards: AllCards
    });

function pileBaseRules$1(game, i) {
  return {
          droppedUpon: (function (gameRemoved, dragPile) {
              var noChildren = game.piles[i].length === 0;
              var dragPileBase = dragPile[0];
              if (noChildren && dragPileBase.card.rank === "RK") {
                return {
                        piles: Common.ArrayAux.update(gameRemoved.piles, i, (function (param) {
                                return dragPile;
                              })),
                        foundations: gameRemoved.foundations,
                        free: gameRemoved.free
                      };
              }
              
            }),
          autoProgress: "Accept",
          onClick: (function (param) {
              
            })
        };
}

function pileRules$1(game, pile, card, i, j) {
  var isLast = j === (pile.length - 1 | 0);
  return {
          locationAdjustment: {
            x: 0,
            y: Math.imul(j, 20),
            z: j + 1 | 0
          },
          baseSpace: {
            TAG: "Pile",
            _0: i
          },
          dragPile: (function () {
              var freeCellCount = game.piles.filter(function (pile) {
                    return pile.length === 0;
                  }).length + game.free.filter(Core__Option.isNone).length | 0;
              var dragPile = pile.slice(j);
              if (GameCommons.decValidation(dragPile) && freeCellCount >= (dragPile.length - 1 | 0)) {
                return dragPile;
              }
              
            }),
          autoProgress: (function () {
              if (isLast) {
                return {
                        TAG: "SendOrAccept",
                        _0: [card]
                      };
              } else {
                return "DoNothing";
              }
            }),
          droppedUpon: (function (game, dragPile) {
              var dragPileBase = dragPile[0];
              if (isLast && Card.rankIsAbove(card, dragPileBase) && dragPileBase.card.suit === card.card.suit) {
                return {
                        piles: game.piles.map(function (stack) {
                              return Common.ArrayAux.insertAfter(stack, card, dragPile);
                            }),
                        foundations: game.foundations,
                        free: game.free
                      };
              }
              
            }),
          onStateChange: (function (param) {
              
            }),
          onClick: (function (param) {
              
            })
        };
}

function forEachSpace$1(game, f) {
  game.piles.forEach(function (pile, i) {
        f({
              TAG: "Pile",
              _0: i
            }, {
              TAG: "Static",
              _0: pileBaseRules$1(game, i)
            });
        pile.forEach(function (card, j) {
              f({
                    TAG: "Card",
                    _0: card.card
                  }, {
                    TAG: "Movable",
                    _0: pileRules$1(game, pile, card, i, j)
                  });
            });
      });
  game.foundations.forEach(function (foundation, i) {
        f({
              TAG: "Foundation",
              _0: i
            }, {
              TAG: "Static",
              _0: foundationBaseRules(i)
            });
        foundation.forEach(function (card, j) {
              f({
                    TAG: "Card",
                    _0: card.card
                  }, {
                    TAG: "Movable",
                    _0: foundationRules(game, foundation, card, i, j)
                  });
            });
      });
  game.free.forEach(function (card, i) {
        f({
              TAG: "Free",
              _0: i
            }, {
              TAG: "Static",
              _0: freeBaseRules(i)
            });
        Core__Option.mapOr(card, undefined, (function (card) {
                f({
                      TAG: "Card",
                      _0: card.card
                    }, {
                      TAG: "Movable",
                      _0: freeRules(card, i)
                    });
              }));
      });
}

var BakersGame = GameBase.Create({
      game_encode: game_encode,
      game_decode: game_decode,
      deck_encode: deck_encode,
      deck_decode: deck_decode,
      getSpace: getSpace,
      spaceToString: spaceToString,
      initiateGame: initiateGame,
      forEachSpace: forEachSpace$1,
      removeDragFromGame: removeDragFromGame,
      winCheck: winCheck,
      applyLiftToDragPile: applyLiftToDragPile,
      applyMoveToDragPile: applyMoveToDragPile,
      Board: StandardBoard,
      AllCards: AllCards
    });

export {
  FreeCellRules ,
  OneDeck ,
  TwoDeck ,
  BakersGame ,
}
/* OneDeck Not a pure module */
