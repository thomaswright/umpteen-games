// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "../Card.res.mjs";
import * as Bases from "./Bases.res.mjs";
import * as Boards from "./Boards.res.mjs";
import * as Common from "../Common.res.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as GameBase from "../GameBase.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as GameCommons from "./GameCommons.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function freeBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              var noChildren = Core__Option.isNone(game.free[i]);
              if (noChildren && dragPile.length === 1) {
                return {
                        piles: game.piles,
                        foundations: game.foundations,
                        stock: game.stock,
                        waste: game.waste,
                        free: Common.ArrayAux.update(game.free, i, (function (param) {
                                return dragPile[0];
                              }))
                      };
              }
              
            }),
          autoProgress: "DoNothing",
          onClick: (function (param) {
              
            })
        };
}

function freeRules(card, i) {
  return {
          locationAdjustment: {
            x: 0,
            y: 0,
            z: 1
          },
          baseSpace: {
            TAG: "Free",
            _0: i
          },
          dragPile: (function () {
              return [card];
            }),
          autoProgress: (function () {
              return {
                      TAG: "Send",
                      _0: [card]
                    };
            }),
          droppedUpon: (function (_game, _dragPile) {
              
            }),
          onStateChange: (function (element) {
              Card.showOrHide(card, element);
            }),
          onClick: (function (param) {
              
            })
        };
}

var FreeCellRules = {
  freeBaseRules: freeBaseRules,
  freeRules: freeRules
};

var forEachSpace = Bases.FreeCell.makeForEachSpace(undefined, undefined, undefined, undefined, undefined, undefined, undefined, freeBaseRules, freeRules);

function initiateGame() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  return [
          shuffledDeck,
          {
            piles: [
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6)
            ],
            foundations: [
              [],
              [],
              [],
              []
            ],
            stock: [],
            waste: [],
            free: [
              undefined,
              undefined,
              undefined,
              undefined
            ]
          }
        ];
}

var OneDeck = GameBase.Create({
      game_encode: Bases.FreeCell.game_encode,
      game_decode: Bases.FreeCell.game_decode,
      deck_encode: Bases.FreeCell.deck_encode,
      deck_decode: Bases.FreeCell.deck_decode,
      getSpace: Bases.FreeCell.getSpace,
      spaceToString: Bases.FreeCell.spaceToString,
      initiateGame: initiateGame,
      forEachSpace: forEachSpace,
      removeDragFromGame: Bases.FreeCell.removeDragFromGame,
      winCheck: Bases.FreeCell.winCheck,
      applyLiftToDragPile: Bases.FreeCell.applyLiftToDragPile,
      applyMoveToDragPile: Bases.FreeCell.applyMoveToDragPile,
      Board: Boards.FreeCell,
      AllCards: Bases.FreeCell.AllCards
    });

var forEachSpace$1 = Bases.FreeCell.makeForEachSpace(undefined, undefined, undefined, undefined, undefined, undefined, undefined, freeBaseRules, freeRules);

function initiateGame$1() {
  var shuffledDeck = Core__Array.toShuffled([].concat(Card.getDeck(0, false), Card.getDeck(1, false)));
  var deckToDeal = {
    contents: shuffledDeck
  };
  return [
          shuffledDeck,
          {
            piles: [
              Common.ArrayAux.popN(deckToDeal, 11),
              Common.ArrayAux.popN(deckToDeal, 11),
              Common.ArrayAux.popN(deckToDeal, 11),
              Common.ArrayAux.popN(deckToDeal, 11),
              Common.ArrayAux.popN(deckToDeal, 10),
              Common.ArrayAux.popN(deckToDeal, 10),
              Common.ArrayAux.popN(deckToDeal, 10),
              Common.ArrayAux.popN(deckToDeal, 10),
              Common.ArrayAux.popN(deckToDeal, 10),
              Common.ArrayAux.popN(deckToDeal, 10)
            ],
            foundations: [
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              []
            ],
            stock: [],
            waste: [],
            free: [
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined
            ]
          }
        ];
}

var TwoDeck = GameBase.Create({
      game_encode: Bases.FreeCell.game_encode,
      game_decode: Bases.FreeCell.game_decode,
      deck_encode: Bases.FreeCell.deck_encode,
      deck_decode: Bases.FreeCell.deck_decode,
      getSpace: Bases.FreeCell.getSpace,
      spaceToString: Bases.FreeCell.spaceToString,
      initiateGame: initiateGame$1,
      forEachSpace: forEachSpace$1,
      removeDragFromGame: Bases.FreeCell.removeDragFromGame,
      winCheck: Bases.FreeCell.winCheck,
      applyLiftToDragPile: Bases.FreeCell.applyLiftToDragPile,
      applyMoveToDragPile: Bases.FreeCell.applyMoveToDragPile,
      Board: Boards.DoubleFreeCell,
      AllCards: Bases.FreeCell.AllCards
    });

function initiateGame$2() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  return [
          shuffledDeck,
          {
            piles: [
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5),
              Common.ArrayAux.popN(deckToDeal, 5)
            ],
            foundations: [
              [],
              [],
              [],
              []
            ],
            stock: [],
            waste: [],
            free: [
              Common.ArrayAux.popN(deckToDeal, 1)[0],
              Common.ArrayAux.popN(deckToDeal, 1)[0],
              undefined,
              undefined
            ]
          }
        ];
}

var forEachSpace$2 = Bases.SeahavenTowers.makeForEachSpace(undefined, undefined, undefined, undefined, undefined, undefined, undefined, freeBaseRules, freeRules);

var SeahavenTowers = GameBase.Create({
      game_encode: Bases.SeahavenTowers.game_encode,
      game_decode: Bases.SeahavenTowers.game_decode,
      deck_encode: Bases.SeahavenTowers.deck_encode,
      deck_decode: Bases.SeahavenTowers.deck_decode,
      getSpace: Bases.SeahavenTowers.getSpace,
      spaceToString: Bases.SeahavenTowers.spaceToString,
      initiateGame: initiateGame$2,
      forEachSpace: forEachSpace$2,
      removeDragFromGame: Bases.SeahavenTowers.removeDragFromGame,
      winCheck: Bases.SeahavenTowers.winCheck,
      applyLiftToDragPile: Bases.SeahavenTowers.applyLiftToDragPile,
      applyMoveToDragPile: Bases.SeahavenTowers.applyMoveToDragPile,
      Board: Boards.FreeCell,
      AllCards: Bases.SeahavenTowers.AllCards
    });

function initiateGame$3() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  var beak = deckToDeal.contents[0];
  var otherBeaks = [];
  deckToDeal.contents = Core__Array.filterMap(deckToDeal.contents, (function (v) {
          if (v.card.rank === beak.card.rank && Caml_obj.notequal(v, beak)) {
            otherBeaks.push(v);
            return ;
          } else {
            return v;
          }
        }));
  return [
          shuffledDeck,
          {
            piles: [
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7),
              Common.ArrayAux.popN(deckToDeal, 7)
            ],
            foundations: [
              [],
              [otherBeaks[0]],
              [otherBeaks[1]],
              [otherBeaks[2]]
            ],
            stock: [],
            waste: [],
            free: [
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined,
              undefined
            ]
          }
        ];
}

function foundationBaseRules(i) {
  return {
          droppedUpon: (function (game, dragPile) {
              var justOne = dragPile.length === 1;
              var dragPileBase = dragPile[0];
              var noChildren = game.piles[i].length === 0;
              var second = game.foundations[1][0];
              if (noChildren && justOne && dragPileBase.card.rank === second.card.rank) {
                return {
                        piles: GameCommons.flipLastUp(game.piles),
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                return dragPile;
                              })),
                        stock: game.stock,
                        waste: game.waste,
                        free: game.free
                      };
              }
              
            }),
          autoProgress: "Seek",
          onClick: (function (param) {
              
            })
        };
}

function pileBaseRules(game, i) {
  return {
          droppedUpon: (function (gameRemoved, dragPile) {
              var dragPileBase = dragPile[0];
              var noChildren = game.piles[i].length === 0;
              var second = game.foundations[1][0];
              if (noChildren && Card.rankIsAboveCyclic(second, dragPileBase)) {
                return {
                        piles: GameCommons.flipLastUp(Common.ArrayAux.update(gameRemoved.piles, i, (function (param) {
                                    return dragPile;
                                  }))),
                        foundations: gameRemoved.foundations,
                        stock: gameRemoved.stock,
                        waste: gameRemoved.waste,
                        free: gameRemoved.free
                      };
              }
              
            }),
          autoProgress: "Accept",
          onClick: (function (param) {
              
            })
        };
}

var forEachSpace$3 = Bases.Penguin.makeForEachSpace(pileBaseRules, undefined, foundationBaseRules, undefined, undefined, undefined, undefined, freeBaseRules, freeRules);

var Penguin = GameBase.Create({
      game_encode: Bases.Penguin.game_encode,
      game_decode: Bases.Penguin.game_decode,
      deck_encode: Bases.Penguin.deck_encode,
      deck_decode: Bases.Penguin.deck_decode,
      getSpace: Bases.Penguin.getSpace,
      spaceToString: Bases.Penguin.spaceToString,
      initiateGame: initiateGame$3,
      forEachSpace: forEachSpace$3,
      removeDragFromGame: Bases.Penguin.removeDragFromGame,
      winCheck: Bases.Penguin.winCheck,
      applyLiftToDragPile: Bases.Penguin.applyLiftToDragPile,
      applyMoveToDragPile: Bases.Penguin.applyMoveToDragPile,
      Board: Boards.EightOff,
      AllCards: Bases.Penguin.AllCards
    });

function initiateGame$4() {
  var shuffledDeck = Core__Array.toShuffled(Card.getDeck(0, false));
  var deckToDeal = {
    contents: shuffledDeck
  };
  return [
          shuffledDeck,
          {
            piles: [
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6),
              Common.ArrayAux.popN(deckToDeal, 6)
            ],
            foundations: [
              Common.ArrayAux.popN(deckToDeal, 1),
              Common.ArrayAux.popN(deckToDeal, 1),
              Common.ArrayAux.popN(deckToDeal, 1),
              Common.ArrayAux.popN(deckToDeal, 1)
            ],
            stock: [],
            waste: [],
            free: [
              undefined,
              undefined
            ]
          }
        ];
}

var forEachSpace$4 = Bases.Stalactite.makeForEachSpace(undefined, undefined, undefined, undefined, undefined, undefined, undefined, freeBaseRules, freeRules);

var Stalactite = GameBase.Create({
      game_encode: Bases.Stalactite.game_encode,
      game_decode: Bases.Stalactite.game_decode,
      deck_encode: Bases.Stalactite.deck_encode,
      deck_decode: Bases.Stalactite.deck_decode,
      getSpace: Bases.Stalactite.getSpace,
      spaceToString: Bases.Stalactite.spaceToString,
      initiateGame: initiateGame$4,
      forEachSpace: forEachSpace$4,
      removeDragFromGame: Bases.Stalactite.removeDragFromGame,
      winCheck: Bases.Stalactite.winCheck,
      applyLiftToDragPile: Bases.Stalactite.applyLiftToDragPile,
      applyMoveToDragPile: Bases.Stalactite.applyMoveToDragPile,
      Board: Boards.FreeCell,
      AllCards: Bases.Stalactite.AllCards
    });

export {
  FreeCellRules ,
  OneDeck ,
  TwoDeck ,
  SeahavenTowers ,
  Penguin ,
  Stalactite ,
}
/* OneDeck Not a pure module */
