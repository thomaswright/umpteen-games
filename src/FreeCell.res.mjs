// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as React from "react";
import * as Common from "./Common.res.mjs";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as GameBase from "./GameBase.res.mjs";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

var shuffledDeck = Card.getShuffledDeck();

function space_encode(value) {
  switch (value.TAG) {
    case "Card" :
        return [
                "Card",
                Card.card_encode(value._0)
              ];
    case "Foundation" :
        return [
                "Foundation",
                Decco.intToJson(value._0)
              ];
    case "Pile" :
        return [
                "Pile",
                Decco.intToJson(value._0)
              ];
    case "Free" :
        return [
                "Free",
                Decco.intToJson(value._0)
              ];
    
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Free" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Free",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$3 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$3.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$3._0
                    }
                  };
          }
          var e$3 = v0$3._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$3.path,
                    message: e$3.message,
                    value: e$3.value
                  }
                };
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

function initiateGame() {
  return {
          piles: [
            shuffledDeck.slice(0, 7),
            shuffledDeck.slice(7, 14),
            shuffledDeck.slice(14, 21),
            shuffledDeck.slice(21, 28),
            shuffledDeck.slice(28, 34),
            shuffledDeck.slice(34, 40),
            shuffledDeck.slice(40, 46),
            shuffledDeck.slice(46, 52)
          ],
          foundations: [
            [],
            [],
            [],
            []
          ],
          free: [
            [],
            [],
            [],
            []
          ],
          gameEnded: false
        };
}

function getSpaceLocs(game) {
  var cards = {
    contents: []
  };
  var addToCards = function (card) {
    cards.contents = cards.contents.concat([card]);
  };
  Common.ArrayAux.forEach2(game.piles, (function (param, card, i, j) {
          addToCards([
                {
                  TAG: "Card",
                  _0: card
                },
                {
                  x: Math.imul(i, 70),
                  y: 200 + Math.imul(j, 20) | 0,
                  z: j + 1 | 0
                }
              ]);
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (param, card, i, j) {
          addToCards([
                {
                  TAG: "Card",
                  _0: card
                },
                {
                  x: 320 + Math.imul(i, 70) | 0,
                  y: 100,
                  z: j + 1 | 0
                }
              ]);
        }));
  Common.ArrayAux.forEach2(game.free, (function (param, card, i, param$1) {
          addToCards([
                {
                  TAG: "Card",
                  _0: card
                },
                {
                  x: Math.imul(i, 70),
                  y: 100,
                  z: 1
                }
              ]);
        }));
  return cards.contents;
}

function baseSpace(dropCard, game) {
  var base = {
    contents: undefined
  };
  Common.ArrayAux.forEach2(game.piles, (function (param, card, i, param$1) {
          if (Caml_obj.equal(card, dropCard)) {
            base.contents = {
              TAG: "Pile",
              _0: i
            };
            return ;
          }
          
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (param, card, i, param$1) {
          if (Caml_obj.equal(card, dropCard)) {
            base.contents = {
              TAG: "Foundation",
              _0: i
            };
            return ;
          }
          
        }));
  Common.ArrayAux.forEach2(game.free, (function (param, card, i, param$1) {
          if (Caml_obj.equal(card, dropCard)) {
            base.contents = {
              TAG: "Free",
              _0: i
            };
            return ;
          }
          
        }));
  return base.contents;
}

function buildDragPile(card, game) {
  var dragPile = {
    contents: []
  };
  Common.ArrayAux.forEach2(game.piles, (function (pile, pileCard, param, j) {
          if (Caml_obj.equal(pileCard, card)) {
            dragPile.contents = pile.slice(j);
            return ;
          }
          
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (pile, pileCard, param, j) {
          if (Caml_obj.equal(pileCard, card)) {
            dragPile.contents = pile.slice(j);
            return ;
          }
          
        }));
  Common.ArrayAux.forEach2(game.free, (function (param, freeCard, param$1, param$2) {
          if (Caml_obj.equal(freeCard, card)) {
            dragPile.contents = [card];
            return ;
          }
          
        }));
  return dragPile.contents;
}

function canDrag(space, game) {
  if (space.TAG !== "Card") {
    return false;
  }
  var card = space._0;
  var dragPile = buildDragPile(card, game);
  var match = baseSpace(card, game);
  var onTopIfNeeded;
  if (match !== undefined) {
    switch (match.TAG) {
      case "Card" :
          onTopIfNeeded = false;
          break;
      case "Foundation" :
          onTopIfNeeded = Core__Option.mapOr(Core__Option.flatMap(game.foundations[match._0], (function (stack) {
                      return Common.ArrayAux.getLast(stack);
                    })), false, (function (top) {
                  return Caml_obj.equal(top, card);
                }));
          break;
      case "Pile" :
          onTopIfNeeded = true;
          break;
      case "Free" :
          onTopIfNeeded = Core__Option.mapOr(Core__Option.flatMap(game.free[match._0], (function (x) {
                      return x[0];
                    })), false, (function (top) {
                  return Caml_obj.equal(top, card);
                }));
          break;
      
    }
  } else {
    onTopIfNeeded = false;
  }
  var match$1 = Core__Array.reduce(dragPile.toReversed(), [
        true,
        undefined
      ], (function (param, onBottom) {
          if (!param[0]) {
            return [
                    false,
                    undefined
                  ];
          }
          var onTop = param[1];
          if (onTop !== undefined) {
            return [
                    Card.rankIsBelow(onTop, onBottom) && Card.color(onTop) !== Card.color(onBottom),
                    onBottom
                  ];
          } else {
            return [
                    true,
                    onBottom
                  ];
          }
        }));
  if (onTopIfNeeded) {
    return match$1[0];
  } else {
    return false;
  }
}

function canDrop(dragSpace, dropSpace, game) {
  if (dragSpace.TAG !== "Card") {
    return false;
  }
  var dragCard = dragSpace._0;
  var dragPile = buildDragPile(dragCard, game);
  var notInDragPile = Core__Option.isNone(dragPile.find(function (pilePiece) {
            return Caml_obj.equal({
                        TAG: "Card",
                        _0: pilePiece
                      }, dropSpace);
          }));
  var dropHasNoChildren;
  switch (dropSpace.TAG) {
    case "Card" :
        dropHasNoChildren = buildDragPile(dropSpace._0, game).length < 2;
        break;
    case "Foundation" :
        dropHasNoChildren = game.foundations[dropSpace._0].length === 0;
        break;
    case "Pile" :
        dropHasNoChildren = game.piles[dropSpace._0].length === 0;
        break;
    case "Free" :
        dropHasNoChildren = game.free[dropSpace._0].length === 0;
        break;
    
  }
  var canBeParent;
  switch (dropSpace.TAG) {
    case "Card" :
        var dropCard = dropSpace._0;
        var match = baseSpace(dropCard, game);
        if (match !== undefined) {
          switch (match.TAG) {
            case "Foundation" :
                canBeParent = Card.rankIsBelow(dropCard, dragCard) && dragCard.suit === dropCard.suit;
                break;
            case "Pile" :
                canBeParent = Card.rankIsAbove(dropCard, dragCard) && Card.color(dragCard) !== Card.color(dropCard);
                break;
            case "Card" :
            case "Free" :
                canBeParent = false;
                break;
            
          }
        } else {
          canBeParent = false;
        }
        break;
    case "Foundation" :
        canBeParent = dragCard.rank === "RA";
        break;
    case "Pile" :
        canBeParent = dragCard.rank === "RK";
        break;
    case "Free" :
        canBeParent = dragPile.length === 1;
        break;
    
  }
  if (notInDragPile && dropHasNoChildren) {
    return canBeParent;
  } else {
    return false;
  }
}

function onDrop(dropOnSpace, dragSpace, game, setGame) {
  if (dragSpace.TAG !== "Card") {
    return ;
  }
  var dragPile = buildDragPile(dragSpace._0, game);
  var removeDragPile = function (x) {
    return x.filter(function (sCard) {
                return !dragPile.some(function (dCard) {
                            return Caml_obj.equal(sCard, dCard);
                          });
              });
  };
  setGame(function (game) {
        return {
                piles: game.piles.map(removeDragPile),
                foundations: game.foundations.map(removeDragPile),
                free: game.free.map(removeDragPile),
                gameEnded: game.gameEnded
              };
      });
  switch (dropOnSpace.TAG) {
    case "Card" :
        var card = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: game.piles.map(function (stack) {
                                  return Common.ArrayAux.insertAfter(stack, card, dragPile);
                                }),
                            foundations: game.foundations.map(function (stack) {
                                  return Common.ArrayAux.insertAfter(stack, card, dragPile);
                                }),
                            free: game.free,
                            gameEnded: game.gameEnded
                          };
                  });
    case "Foundation" :
        var i = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: game.piles,
                            foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                    return dragPile;
                                  })),
                            free: game.free,
                            gameEnded: game.gameEnded
                          };
                  });
    case "Pile" :
        var i$1 = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: Common.ArrayAux.update(game.piles, i$1, (function (param) {
                                    return dragPile;
                                  })),
                            foundations: game.foundations,
                            free: game.free,
                            gameEnded: game.gameEnded
                          };
                  });
    case "Free" :
        var i$2 = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: game.piles,
                            foundations: game.foundations,
                            free: Common.ArrayAux.update(game.free, i$2, (function (param) {
                                    return dragPile;
                                  })),
                            gameEnded: game.gameEnded
                          };
                  });
    
  }
}

function applyMoveToOthers(space, game, move) {
  if (space.TAG !== "Card") {
    return ;
  }
  var card = space._0;
  Common.ArrayAux.forEach2(game.foundations, (function (stack, sCard, param, j) {
          if (Caml_obj.equal(card, sCard)) {
            return Core__Option.mapOr(stack[j + 1 | 0], undefined, (function (x) {
                          move({
                                TAG: "Card",
                                _0: x
                              });
                        }));
          }
          
        }));
  Common.ArrayAux.forEach2(game.piles, (function (stack, sCard, param, j) {
          if (Caml_obj.equal(card, sCard)) {
            return Core__Option.mapOr(stack[j + 1 | 0], undefined, (function (x) {
                          move({
                                TAG: "Card",
                                _0: x
                              });
                        }));
          }
          
        }));
}

function autoProgress(setGame) {
  var newGame = {
    contents: undefined
  };
  setGame(function (game) {
        game.foundations.forEach(function (foundation, i) {
              var canMove = function (c) {
                var foundationCard = Common.ArrayAux.getLast(foundation);
                if (foundationCard !== undefined) {
                  if (Card.rankIsBelow(foundationCard, c)) {
                    return foundationCard.suit === c.suit;
                  } else {
                    return false;
                  }
                } else {
                  return c.rank === "RA";
                }
              };
              Common.ArrayAux.forEach2(game.free, (function (param, freeCard, freeIndex, param$1) {
                      if (Core__Option.isNone(newGame.contents) && canMove(freeCard)) {
                        newGame.contents = {
                          piles: game.piles,
                          foundations: Common.ArrayAux.update(game.foundations, i, (function (f) {
                                  return f.concat([freeCard]);
                                })),
                          free: Common.ArrayAux.update(game.free, freeIndex, (function (param) {
                                  return [];
                                })),
                          gameEnded: game.gameEnded
                        };
                        return ;
                      }
                      
                    }));
              game.piles.forEach(function (pile, j) {
                    Core__Option.mapOr(Common.ArrayAux.getLast(pile), undefined, (function (pileCard) {
                            if (Core__Option.isNone(newGame.contents) && canMove(pileCard)) {
                              newGame.contents = {
                                piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                                        return Common.ArrayAux.removeLast(p);
                                      })),
                                foundations: Common.ArrayAux.update(game.foundations, i, (function (f) {
                                        return f.concat([pileCard]);
                                      })),
                                free: game.free,
                                gameEnded: game.gameEnded
                              };
                              return ;
                            }
                            
                          }));
                  });
            });
        return Core__Option.getOr(newGame.contents, game);
      });
  return Core__Option.isSome(newGame.contents);
}

function FreeCell$GameRules$Independent(props) {
  var onMouseDown = props.onMouseDown;
  var setRef = props.setRef;
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                [
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Free",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100 rounded w-14 h-20",
                                  style: {
                                    left: Math.imul(i, 70).toString() + "px",
                                    top: "100px",
                                    zIndex: "0"
                                  }
                                }, JSON.stringify(space_encode({
                                          TAG: "Free",
                                          _0: i
                                        })));
                    }),
                [
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Foundation",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100 rounded w-14 h-20",
                                  style: {
                                    left: (320 + Math.imul(i, 70) | 0).toString() + "px",
                                    top: "100px",
                                    zIndex: "0"
                                  }
                                }, JSON.stringify(space_encode({
                                          TAG: "Foundation",
                                          _0: i
                                        })));
                    }),
                [
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Pile",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100  rounded w-14 h-20",
                                  style: {
                                    left: Math.imul(i, 70).toString() + "px",
                                    top: "200px",
                                    zIndex: "0"
                                  }
                                }, JSON.stringify(space_encode({
                                          TAG: "Pile",
                                          _0: i
                                        })));
                    }),
                shuffledDeck.map(function (card) {
                      return JsxRuntime.jsx(Card.Display.make, {
                                  card: card,
                                  id: JSON.stringify(space_encode({
                                            TAG: "Card",
                                            _0: card
                                          })),
                                  cardRef: setRef({
                                        TAG: "Card",
                                        _0: card
                                      }),
                                  onMouseDown: onMouseDown
                                }, JSON.stringify(space_encode({
                                          TAG: "Card",
                                          _0: card
                                        })));
                    })
              ]
            });
}

var Independent = {
  make: FreeCell$GameRules$Independent
};

function FreeCell$GameRules$Dependent(props) {
  return null;
}

var Dependent = {
  make: FreeCell$GameRules$Dependent
};

var GameRules = {
  foundationOffset: 320,
  shuffledDeck: shuffledDeck,
  space_encode: space_encode,
  space_decode: space_decode,
  getSpace: getSpace,
  spaceToString: spaceToString,
  initiateGame: initiateGame,
  getSpaceLocs: getSpaceLocs,
  baseSpace: baseSpace,
  buildDragPile: buildDragPile,
  canDrag: canDrag,
  canDrop: canDrop,
  onDrop: onDrop,
  applyMoveToOthers: applyMoveToOthers,
  autoProgress: autoProgress,
  Independent: Independent,
  Dependent: Dependent
};

var Game = GameBase.GameBase({
      getSpace: getSpace,
      spaceToString: spaceToString,
      initiateGame: initiateGame,
      getSpaceLocs: getSpaceLocs,
      applyMoveToOthers: applyMoveToOthers,
      canDrag: canDrag,
      canDrop: canDrop,
      onDrop: onDrop,
      autoProgress: autoProgress,
      Independent: Independent,
      Dependent: Dependent
    });

export {
  GameRules ,
  Game ,
}
/* shuffledDeck Not a pure module */
