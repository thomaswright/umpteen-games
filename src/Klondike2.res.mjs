// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as React from "react";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as OtherJs from "./other.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function runInterval(prim0, prim1, prim2) {
  OtherJs.runInterval(prim0, prim1, prim2);
}

function removeLast(a) {
  return a.toReversed().slice(1).toReversed();
}

function getLast(a) {
  return a.toReversed()[0];
}

function update(a, i, f) {
  return a.map(function (el, j) {
              if (j === i) {
                return f(el);
              } else {
                return el;
              }
            });
}

function forEach2(a, f) {
  a.forEach(function (el1, i) {
        el1.forEach(function (el2, j) {
              f(el1, el2, i, j);
            });
      });
}

var ArrayAux = {
  removeLast: removeLast,
  getLast: getLast,
  update: update,
  forEach2: forEach2
};

function space_encode(value) {
  if (typeof value !== "object") {
    if (value === "Waste") {
      return ["Waste"];
    } else {
      return ["Stock"];
    }
  }
  switch (value.TAG) {
    case "Card" :
        return [
                "Card",
                Card.card_encode(value._0)
              ];
    case "Foundation" :
        return [
                "Foundation",
                Decco.intToJson(value._0)
              ];
    case "Pile" :
        return [
                "Pile",
                Decco.intToJson(value._0)
              ];
    
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "Stock" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Stock"
                  };
          }
      case "Waste" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Waste"
                  };
          }
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function initiateGame(shuffledDeck) {
  return {
          piles: [
            shuffledDeck.slice(0, 1),
            shuffledDeck.slice(1, 3),
            shuffledDeck.slice(3, 6),
            shuffledDeck.slice(6, 10),
            shuffledDeck.slice(10, 15),
            shuffledDeck.slice(15, 21),
            shuffledDeck.slice(21, 28)
          ],
          foundations: [
            [],
            [],
            [],
            []
          ],
          stock: shuffledDeck.slice(28),
          waste: [],
          gameEnded: false
        };
}

function cardLocs(game) {
  var cards = {
    contents: []
  };
  var addToCards = function (card) {
    cards.contents = cards.contents.concat([card]);
  };
  forEach2(game.piles, (function (param, card, i, j) {
          addToCards({
                card: card,
                x: Math.imul(i, 70),
                y: 200 + Math.imul(j, 20) | 0,
                z: j + 1 | 0
              });
        }));
  forEach2(game.foundations, (function (param, card, i, j) {
          addToCards({
                card: card,
                x: Math.imul(i, 70),
                y: 100,
                z: j + 1 | 0
              });
        }));
  game.stock.forEach(function (card, i) {
        addToCards({
              card: card,
              x: 0,
              y: 0,
              z: i + 1 | 0
            });
      });
  game.waste.forEach(function (card, i) {
        addToCards({
              card: card,
              x: 70 + Math.imul(20, i % 3) | 0,
              y: 0,
              z: i + 1 | 0
            });
      });
  return cards.contents;
}

function baseSpace(dropCard, game) {
  var base = {
    contents: undefined
  };
  forEach2(game.piles, (function (param, card, i, param$1) {
          if (Caml_obj.equal(card, dropCard)) {
            base.contents = {
              TAG: "Pile",
              _0: i
            };
            return ;
          }
          
        }));
  forEach2(game.foundations, (function (param, card, i, param$1) {
          if (Caml_obj.equal(card, dropCard)) {
            base.contents = {
              TAG: "Foundation",
              _0: i
            };
            return ;
          }
          
        }));
  game.waste.forEach(function (card) {
        if (Caml_obj.equal(card, dropCard)) {
          base.contents = "Waste";
          return ;
        }
        
      });
  game.stock.forEach(function (card) {
        if (Caml_obj.equal(card, dropCard)) {
          base.contents = "Stock";
          return ;
        }
        
      });
  return base.contents;
}

function buildDragPile(card, game) {
  var dragPile = {
    contents: []
  };
  forEach2(game.piles, (function (pile, pileCard, param, j) {
          if (Caml_obj.equal(pileCard, card)) {
            dragPile.contents = pile.slice(j);
            return ;
          }
          
        }));
  forEach2(game.foundations, (function (pile, pileCard, param, j) {
          if (Caml_obj.equal(pileCard, card)) {
            dragPile.contents = pile.slice(j);
            return ;
          }
          
        }));
  game.waste.forEach(function (wasteCard) {
        if (Caml_obj.equal(wasteCard, card)) {
          dragPile.contents = [card];
          return ;
        }
        
      });
  return dragPile.contents;
}

function canDrag(card, game) {
  var dragPile = buildDragPile(card, game);
  var match = baseSpace(card, game);
  var onTop;
  if (match !== undefined) {
    if (typeof match !== "object") {
      onTop = match === "Waste" ? Core__Option.mapOr(game.waste.toReversed()[0], false, (function (top) {
                return Caml_obj.equal(top, card);
              })) : false;
    } else {
      switch (match.TAG) {
        case "Card" :
            onTop = false;
            break;
        case "Foundation" :
            onTop = Core__Option.mapOr(Core__Option.flatMap(game.foundations[match._0], (function (stack) {
                        return stack.toReversed()[0];
                      })), false, (function (top) {
                    return Caml_obj.equal(top, card);
                  }));
            break;
        case "Pile" :
            onTop = Core__Option.mapOr(Core__Option.flatMap(game.piles[match._0], (function (stack) {
                        return stack.toReversed()[0];
                      })), false, (function (top) {
                    return Caml_obj.equal(top, card);
                  }));
            break;
        
      }
    }
  } else {
    onTop = false;
  }
  var match$1 = Core__Array.reduce(dragPile.toReversed(), [
        true,
        undefined
      ], (function (param, onBottom) {
          if (!param[0]) {
            return [
                    false,
                    undefined
                  ];
          }
          var onTop = param[1];
          if (onTop !== undefined) {
            return [
                    Card.rankIsBelow(onTop, onBottom) && Card.color(onTop) !== Card.color(onBottom),
                    onBottom
                  ];
          } else {
            return [
                    true,
                    onBottom
                  ];
          }
        }));
  if (onTop) {
    return match$1[0];
  } else {
    return false;
  }
}

function canDrop(dragCard, dropSpace, game) {
  var dragPile = buildDragPile(dragCard, game);
  var notInDragPile = Core__Option.isNone(dragPile.find(function (pilePiece) {
            return Caml_obj.equal({
                        TAG: "Card",
                        _0: pilePiece
                      }, dropSpace);
          }));
  var dropHasNoChildren;
  if (typeof dropSpace !== "object") {
    dropHasNoChildren = false;
  } else {
    switch (dropSpace.TAG) {
      case "Card" :
          dropHasNoChildren = buildDragPile(dropSpace._0, game).length < 2;
          break;
      case "Foundation" :
          dropHasNoChildren = game.foundations[dropSpace._0].length === 0;
          break;
      case "Pile" :
          dropHasNoChildren = game.piles[dropSpace._0].length === 0;
          break;
      
    }
  }
  var canBeParent;
  if (typeof dropSpace !== "object") {
    canBeParent = false;
  } else {
    switch (dropSpace.TAG) {
      case "Card" :
          var dropCard = dropSpace._0;
          var match = baseSpace(dropCard, game);
          if (match !== undefined && typeof match === "object") {
            switch (match.TAG) {
              case "Foundation" :
                  canBeParent = Card.rankIsBelow(dropCard, dragCard) && dragCard.suit === dropCard.suit;
                  break;
              case "Pile" :
                  canBeParent = Card.rankIsAbove(dropCard, dragCard) && Card.color(dragCard) !== Card.color(dropCard);
                  break;
              default:
                canBeParent = false;
            }
          } else {
            canBeParent = false;
          }
          break;
      case "Foundation" :
          canBeParent = dragCard.rank === "RA";
          break;
      case "Pile" :
          canBeParent = dragCard.rank === "RK";
          break;
      
    }
  }
  if (notInDragPile && dropHasNoChildren) {
    return canBeParent;
  } else {
    return false;
  }
}

function onDrop(dropOnSpace, dragCard, game, setGame) {
  var dragPile = buildDragPile(dragCard, game);
  var removeDragPile = function (x) {
    return x.filter(function (sCard) {
                return !dragPile.some(function (dCard) {
                            return Caml_obj.equal(sCard, dCard);
                          });
              });
  };
  setGame(function (game) {
        return {
                piles: game.piles.map(removeDragPile),
                foundations: game.foundations.map(removeDragPile),
                stock: removeDragPile(game.stock),
                waste: removeDragPile(game.waste),
                gameEnded: game.gameEnded
              };
      });
  if (typeof dropOnSpace !== "object") {
    return ;
  }
  switch (dropOnSpace.TAG) {
    case "Card" :
        var card = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: game.piles.map(function (stack) {
                                  return Core__Array.reduce(stack, [], (function (acc, sCard) {
                                                if (Caml_obj.equal(sCard, card)) {
                                                  return acc.concat([sCard].concat(dragPile));
                                                } else {
                                                  return acc.concat([sCard]);
                                                }
                                              }));
                                }),
                            foundations: game.foundations.map(function (stack) {
                                  return Core__Array.reduce(stack, [], (function (acc, sCard) {
                                                if (Caml_obj.equal(sCard, card)) {
                                                  return acc.concat([sCard].concat(dragPile));
                                                } else {
                                                  return acc.concat([sCard]);
                                                }
                                              }));
                                }),
                            stock: game.stock,
                            waste: game.waste,
                            gameEnded: game.gameEnded
                          };
                  });
    case "Foundation" :
        var i = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: game.piles,
                            foundations: game.foundations.map(function (foundation, fi) {
                                  if (fi === i) {
                                    return dragPile;
                                  } else {
                                    return foundation;
                                  }
                                }),
                            stock: game.stock,
                            waste: game.waste,
                            gameEnded: game.gameEnded
                          };
                  });
    case "Pile" :
        var i$1 = dropOnSpace._0;
        return setGame(function (game) {
                    return {
                            piles: game.piles.map(function (pile, pi) {
                                  if (pi === i$1) {
                                    return dragPile;
                                  } else {
                                    return pile;
                                  }
                                }),
                            foundations: game.foundations,
                            stock: game.stock,
                            waste: game.waste,
                            gameEnded: game.gameEnded
                          };
                  });
    
  }
}

function applyToOthers(card, game, f) {
  forEach2(game.foundations, (function (stack, sCard, param, j) {
          if (Caml_obj.equal(card, sCard)) {
            return f(stack[j + 1 | 0]);
          }
          
        }));
  forEach2(game.piles, (function (stack, sCard, param, j) {
          if (Caml_obj.equal(card, sCard)) {
            return f(stack[j + 1 | 0]);
          }
          
        }));
}

function autoProgress(setGame, moveToState) {
  setGame(function (game) {
        var newGame = {
          contents: undefined
        };
        game.foundations.forEach(function (foundation, i) {
              game.piles.forEach(function (pile) {
                    Core__Option.mapOr(pile.toReversed()[0], undefined, (function (pileCard) {
                            var foundationCard = foundation.toReversed()[0];
                            var canMove = foundationCard !== undefined ? Card.rankIsAbove(foundationCard, pileCard) && foundationCard.suit === pileCard.suit : pileCard.rank === "RA";
                            if (Core__Option.isNone(newGame.contents) && canMove) {
                              newGame.contents = {
                                piles: update(game.piles, i, (function (p) {
                                        return removeLast(p);
                                      })),
                                foundations: update(game.foundations, i, (function (f) {
                                        return f.concat([pileCard]);
                                      })),
                                stock: game.stock,
                                waste: game.waste,
                                gameEnded: game.gameEnded
                              };
                              return ;
                            }
                            
                          }));
                  });
            });
        return Core__Option.getOr(newGame.contents, game);
      });
  return moveToState();
}

function dealToWaste(setGame, moveToState) {
  var f = function () {
    setGame(function (game) {
          if (game.stock.length === 0) {
            return {
                    piles: game.piles,
                    foundations: game.foundations,
                    stock: game.waste,
                    waste: [],
                    gameEnded: game.gameEnded
                  };
          } else {
            return {
                    piles: game.piles,
                    foundations: game.foundations,
                    stock: game.stock.slice(1),
                    waste: game.waste.concat(game.stock.slice(0, 1)),
                    gameEnded: game.gameEnded
                  };
          }
        });
    moveToState();
  };
  runInterval(f, 300, 3);
}

var Custom = {
  dealToWaste: dealToWaste
};

var GameRules = {
  space_encode: space_encode,
  space_decode: space_decode,
  initiateGame: initiateGame,
  cardLocs: cardLocs,
  baseSpace: baseSpace,
  buildDragPile: buildDragPile,
  canDrag: canDrag,
  canDrop: canDrop,
  onDrop: onDrop,
  applyToOthers: applyToOthers,
  autoProgress: autoProgress,
  Custom: Custom
};

function getShuffledDeck() {
  return Core__Array.toShuffled(Core__Array.reduce(Card.allRanks, [], (function (a, rank) {
                    return Core__Array.reduce(Card.allSuits, a, (function (a2, suit) {
                                  return a2.concat([{
                                                suit: suit,
                                                rank: rank
                                              }]);
                                }));
                  })));
}

var shuffledDeck = getShuffledDeck();

function appendReactElement(prim0, prim1) {
  OtherJs.appendReactElement(prim0, prim1);
}

function zIndexFromElement(element) {
  return Core__Int.fromString(element.style["z-index"], undefined);
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

function elementPosition(element) {
  var a = element.getBoundingClientRect();
  return {
          top: a.top,
          right: a.right,
          bottom: a.bottom,
          left: a.left
        };
}

function eventPosition($$event) {
  return elementPosition($$event.currentTarget);
}

function Klondike2$CardDisplay(props) {
  var card = props.card;
  var match = card.rank;
  var tmp;
  tmp = match === "R10" ? "tracking-[-0.1rem] w-4" : "w-3.5";
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: JsxRuntime.jsxs("span", {
                          children: [
                            JsxRuntime.jsxs("span", {
                                  children: [
                                    JsxRuntime.jsx("span", {
                                          children: Card.rankString(card),
                                          className: [
                                              "font-medium ",
                                              tmp
                                            ].join(" ")
                                        }),
                                    JsxRuntime.jsx("span", {
                                          children: Card.suitString(card),
                                          className: "w-3.5 flex flex-row justify-center"
                                        })
                                  ],
                                  className: "flex flex-row"
                                }),
                            JsxRuntime.jsx("span", {
                                  children: Card.suitString(card),
                                  className: "w-3.5 flex flex-row mt-0.5 -ml-0.5"
                                })
                          ],
                          className: "flex flex-col"
                        }),
                    className: [" border border-gray-300 rounded w-14 h-20 bg-white shadow-sm px-1 leading-none py-0.5 cursor-default"].join(" "),
                    style: {
                      color: Card.colorHex(card),
                      transform: Card.rotation(card)
                    }
                  }),
              ref: Caml_option.some(props.cardRef),
              className: "absolute w-14 h-20 select-none",
              id: props.id,
              onMouseDown: props.onMouseDown
            });
}

var CardDisplay = {
  make: Klondike2$CardDisplay
};

function Klondike2(props) {
  var undoStats = React.useRef({
        currentUndoDepth: 0,
        undos: []
      });
  var setUndoStats = function (f) {
    undoStats.current = f(undoStats.current);
  };
  var state = React.useRef({
        history: [initiateGame(shuffledDeck)]
      });
  var getGame = function () {
    return state.current.history[state.current.history.length - 1 | 0];
  };
  var setGame = function (f) {
    console.log("setGame");
    if (undoStats.current.currentUndoDepth > 0) {
      setUndoStats(function (undoStats) {
            return {
                    currentUndoDepth: 0,
                    undos: undoStats.undos.concat([undoStats.currentUndoDepth])
                  };
          });
    }
    var f$1 = function (state) {
      var newGame = f(getGame());
      return {
              history: state.history.concat([newGame])
            };
    };
    state.current = f$1(state.current);
  };
  var refs = React.useRef([]);
  var dragCard = React.useRef(undefined);
  var offset = React.useRef([
        0,
        0
      ]);
  var originalData = React.useRef(undefined);
  var getElement = function (a) {
    return refs.current.find(function (el) {
                return Caml_obj.equal(getSpace(el), a);
              });
  };
  var setRef = function (card) {
    return function (element) {
      if (element === null || element === undefined) {
        return ;
      }
      element.id = spaceToString(card);
      refs.current.push(element);
    };
  };
  var applyToOthers$1 = function (element, f) {
    var match = getSpace(element);
    if (match === undefined) {
      return ;
    }
    if (typeof match !== "object") {
      return ;
    }
    if (match.TAG !== "Card") {
      return ;
    }
    var game = getGame();
    var appliedF = function (space) {
      Core__Option.mapOr(Core__Option.flatMap(space, (function (x) {
                  return getElement({
                              TAG: "Card",
                              _0: x
                            });
                })), undefined, (function (childEl) {
              f(childEl);
            }));
    };
    applyToOthers(match._0, game, appliedF);
  };
  var move = function (element, left, top, zIndex, offset) {
    element.style.left = left.toString() + "px";
    element.style.top = top.toString() + "px";
    Core__Option.mapOr(zIndex, undefined, (function (zIndex) {
            element.style["z-index"] = zIndex.toString();
          }));
    Core__Option.mapOr(offset, undefined, (function (param) {
            var topOffset = param[1];
            var leftOffset = param[0];
            applyToOthers$1(element, (function (childEl) {
                    move(childEl, left + leftOffset | 0, top + topOffset | 0, Core__Option.map(zIndex, (function (zIndex) {
                                return zIndex + 1 | 0;
                              })), offset);
                  }));
          }));
  };
  var moveToState = function () {
    cardLocs(getGame()).forEach(function (a) {
          var element = getElement({
                TAG: "Card",
                _0: a.card
              });
          if (element !== undefined) {
            var element$1 = Caml_option.valFromOption(element);
            var targetLeft = a.x;
            var targetTop = a.y;
            var zIndex = a.z;
            var offset;
            var duration = 100;
            var start = elementPosition(element$1);
            var boardPos = Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
                }, (function (board) {
                    return elementPosition(board);
                  }));
            var start_top = start.top - boardPos.top;
            var start_right = start.right - boardPos.right;
            var start_bottom = start.bottom - boardPos.bottom;
            var start_left = start.left - boardPos.left;
            var startTime = performance.now();
            var step = function (currentTime) {
              var elapsedTime = currentTime - startTime;
              var progress = Math.min(elapsedTime / duration, 1);
              var leftMove = start_left + (targetLeft - start_left) * progress;
              var topMove = start_top + (targetTop - start_top) * progress;
              move(element$1, leftMove | 0, topMove | 0, zIndex, offset);
              if (progress < 1) {
                requestAnimationFrame(step);
                return ;
              }
              
            };
            requestAnimationFrame(step);
            return ;
          }
          
        });
  };
  var liftUp = function (element, zIndex) {
    element.style["z-index"] = zIndex.toString();
    applyToOthers$1(element, (function (childEl) {
            liftUp(childEl, zIndex + 1 | 0);
          }));
  };
  var getOverlap = function (aEl, bEl) {
    var aPos = elementPosition(aEl);
    var bPos = elementPosition(bEl);
    var overlapX = Math.max(0, Math.min(aPos.right, bPos.right) - Math.max(aPos.left, bPos.left));
    var overlapY = Math.max(0, Math.min(aPos.bottom, bPos.bottom) - Math.max(aPos.top, bPos.top));
    return overlapX * overlapY;
  };
  var onMouseDown = function ($$event) {
    var eventElement = $$event.currentTarget;
    var match = getSpace(eventElement);
    if (match === undefined) {
      return ;
    }
    if (typeof match !== "object") {
      return ;
    }
    if (match.TAG !== "Card") {
      return ;
    }
    if (!canDrag(match._0, getGame())) {
      return ;
    }
    dragCard.current = Caml_option.some(eventElement);
    var dragCardPos = elementPosition(eventElement);
    var boardPos = Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }, (function (board) {
            return elementPosition(board);
          }));
    originalData.current = Core__Option.map(zIndexFromElement(eventElement), (function (v) {
            return [
                    dragCardPos,
                    v
                  ];
          }));
    liftUp(eventElement, 1000);
    var pos = elementPosition($$event.currentTarget);
    offset.current = [
      ($$event.clientX - (pos.left | 0) | 0) + (boardPos.left | 0) | 0,
      ($$event.clientY - (pos.top | 0) | 0) + (boardPos.top | 0) | 0
    ];
  };
  var onMouseMove = function ($$event) {
    Core__Option.mapOr(dragCard.current, undefined, (function (dragCard) {
            var match = offset.current;
            var leftMove = $$event.clientX - match[0] | 0;
            var topMove = $$event.clientY - match[1] | 0;
            move(dragCard, leftMove, topMove, undefined, [
                  0,
                  20
                ]);
          }));
  };
  var getDragCard = function () {
    var dragCardEl = dragCard.current;
    if (dragCardEl === undefined) {
      return ;
    }
    var dragCardEl$1 = Caml_option.valFromOption(dragCardEl);
    var match = getSpace(dragCardEl$1);
    if (match !== undefined && !(typeof match !== "object" || match.TAG !== "Card")) {
      return [
              dragCardEl$1,
              match._0
            ];
    }
    
  };
  var onMouseUp = function (param) {
    var match = getDragCard();
    if (match !== undefined) {
      var dragCard$1 = match[1];
      var dragCardEl = match[0];
      var dropOn = Core__Option.map(Core__Array.reduce(refs.current, undefined, (function (acc, el) {
                  return Core__Option.mapOr(getSpace(el), acc, (function (elSpace) {
                                if (!canDrop(dragCard$1, elSpace, getGame())) {
                                  return acc;
                                }
                                var overlap = getOverlap(el, dragCardEl);
                                var $$new = [
                                  overlap,
                                  el
                                ];
                                if (overlap > 0 && !(acc !== undefined && acc[0] > overlap)) {
                                  return $$new;
                                } else {
                                  return acc;
                                }
                              }));
                })), (function (param) {
              return param[1];
            }));
      if (dropOn !== undefined) {
        var dropOnSpace = getSpace(Caml_option.valFromOption(dropOn));
        if (dropOnSpace !== undefined) {
          onDrop(dropOnSpace, dragCard$1, getGame(), setGame);
        }
        
      }
      
    }
    moveToState();
    dragCard.current = undefined;
  };
  React.useEffect((function () {
          console.log("useEffect");
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("mouseup", onMouseUp);
          moveToState();
          autoProgress(setGame, moveToState);
        }), []);
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("div", {
                      className: "absolute bg-blue-700 rounded w-14 h-20",
                      style: {
                        left: "0px",
                        top: "0px",
                        zIndex: "53"
                      },
                      onClick: (function (param) {
                          dealToWaste(setGame, moveToState);
                        })
                    }, "stock-cover"),
                [
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Foundation",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100 rounded w-14 h-20",
                                  style: {
                                    left: Math.imul(i, 70).toString() + "px",
                                    top: "100px",
                                    zIndex: "0"
                                  }
                                }, spaceToString({
                                      TAG: "Foundation",
                                      _0: i
                                    }));
                    }),
                [
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Pile",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100  rounded w-14 h-20",
                                  style: {
                                    left: Math.imul(i, 70).toString() + "px",
                                    top: "200px",
                                    zIndex: "0"
                                  }
                                }, spaceToString({
                                      TAG: "Pile",
                                      _0: i
                                    }));
                    }),
                shuffledDeck.map(function (card) {
                      return JsxRuntime.jsx(Klondike2$CardDisplay, {
                                  card: card,
                                  id: spaceToString({
                                        TAG: "Card",
                                        _0: card
                                      }),
                                  cardRef: setRef({
                                        TAG: "Card",
                                        _0: card
                                      }),
                                  onMouseDown: onMouseDown
                                }, spaceToString({
                                      TAG: "Card",
                                      _0: card
                                    }));
                    })
              ],
              className: "relative m-5",
              id: "board"
            });
}

var make = Klondike2;

export {
  runInterval ,
  ArrayAux ,
  GameRules ,
  getShuffledDeck ,
  shuffledDeck ,
  appendReactElement ,
  zIndexFromElement ,
  getSpace ,
  spaceToString ,
  elementPosition ,
  eventPosition ,
  CardDisplay ,
  make ,
}
/* shuffledDeck Not a pure module */
