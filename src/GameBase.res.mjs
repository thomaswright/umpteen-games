// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as React from "react";
import * as Common from "./Common.res.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as OtherJs from "./other.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function condInterval(prim0, prim1, prim2) {
  OtherJs.condInterval(prim0, prim1, prim2);
}

function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}

function stateActor_encode(value) {
  if (value === "User") {
    return ["User"];
  } else {
    return ["Auto"];
  }
}

function stateActor_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Auto" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Auto"
                  };
          }
      case "User" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "User"
                  };
          }
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function Create(GameRules) {
  var appendReactElement = function (prim0, prim1) {
    OtherJs.appendReactElement(prim0, prim1);
  };
  var zIndexFromElement = function (element) {
    return Core__Int.fromString(element.style["z-index"], undefined);
  };
  var historySnapshot_encode = function (value) {
    return Js_dict.fromArray([
                [
                  "game",
                  GameRules.game_encode(value.game)
                ],
                [
                  "actor",
                  stateActor_encode(value.actor)
                ]
              ]);
  };
  var historySnapshot_decode = function (value) {
    var dict = Js_json.classify(value);
    if (typeof dict !== "object") {
      return Decco.error(undefined, "Not an object", value);
    }
    if (dict.TAG !== "JSONObject") {
      return Decco.error(undefined, "Not an object", value);
    }
    var dict$1 = dict._0;
    var game = Curry._1(GameRules.game_decode, Belt_Option.getWithDefault(Js_dict.get(dict$1, "game"), null));
    if (game.TAG === "Ok") {
      var actor = stateActor_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "actor"), null));
      if (actor.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: Decco.unsafeAddFieldToObject("game", game._0, Decco.unsafeAddFieldToObject("actor", actor._0, {}))
              };
      }
      var e = actor._0;
      return {
              TAG: "Error",
              _0: {
                path: ".actor" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = game._0;
    return {
            TAG: "Error",
            _0: {
              path: ".game" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  };
  var elementPosition = function (element) {
    var a = element.getBoundingClientRect();
    return {
            top: a.top,
            right: a.right,
            bottom: a.bottom,
            left: a.left
          };
  };
  var eventPosition = function ($$event) {
    return elementPosition($$event.currentTarget);
  };
  var undoStats_encode = function (value) {
    return Js_dict.fromArray([
                [
                  "currentUndoDepth",
                  Decco.intToJson(value.currentUndoDepth)
                ],
                [
                  "undos",
                  (function (extra) {
                        return Decco.arrayToJson(Decco.intToJson, extra);
                      })(value.undos)
                ]
              ]);
  };
  var undoStats_decode = function (value) {
    var dict = Js_json.classify(value);
    if (typeof dict !== "object") {
      return Decco.error(undefined, "Not an object", value);
    }
    if (dict.TAG !== "JSONObject") {
      return Decco.error(undefined, "Not an object", value);
    }
    var dict$1 = dict._0;
    var currentUndoDepth = Decco.intFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "currentUndoDepth"), null));
    if (currentUndoDepth.TAG === "Ok") {
      var extra = Belt_Option.getWithDefault(Js_dict.get(dict$1, "undos"), null);
      var undos = Decco.arrayFromJson(Decco.intFromJson, extra);
      if (undos.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: Decco.unsafeAddFieldToObject("currentUndoDepth", currentUndoDepth._0, Decco.unsafeAddFieldToObject("undos", undos._0, {}))
              };
      }
      var e = undos._0;
      return {
              TAG: "Error",
              _0: {
                path: ".undos" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = currentUndoDepth._0;
    return {
            TAG: "Error",
            _0: {
              path: ".currentUndoDepth" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  };
  var state_encode = function (value) {
    return Js_dict.fromArray([
                [
                  "deck",
                  GameRules.deck_encode(value.deck)
                ],
                [
                  "history",
                  (function (extra) {
                        return Decco.arrayToJson(historySnapshot_encode, extra);
                      })(value.history)
                ],
                [
                  "undoStats",
                  undoStats_encode(value.undoStats)
                ]
              ]);
  };
  var state_decode = function (value) {
    var dict = Js_json.classify(value);
    if (typeof dict !== "object") {
      return Decco.error(undefined, "Not an object", value);
    }
    if (dict.TAG !== "JSONObject") {
      return Decco.error(undefined, "Not an object", value);
    }
    var dict$1 = dict._0;
    var deck = Curry._1(GameRules.deck_decode, Belt_Option.getWithDefault(Js_dict.get(dict$1, "deck"), null));
    if (deck.TAG === "Ok") {
      var history = Decco.arrayFromJson(historySnapshot_decode, Belt_Option.getWithDefault(Js_dict.get(dict$1, "history"), null));
      if (history.TAG === "Ok") {
        var undoStats = undoStats_decode(Belt_Option.getWithDefault(Js_dict.get(dict$1, "undoStats"), null));
        if (undoStats.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: Decco.unsafeAddFieldToObject("deck", deck._0, Decco.unsafeAddFieldToObject("history", history._0, Decco.unsafeAddFieldToObject("undoStats", undoStats._0, {})))
                };
        }
        var e = undoStats._0;
        return {
                TAG: "Error",
                _0: {
                  path: ".undoStats" + e.path,
                  message: e.message,
                  value: e.value
                }
              };
      }
      var e$1 = history._0;
      return {
              TAG: "Error",
              _0: {
                path: ".history" + e$1.path,
                message: e$1.message,
                value: e$1.value
              }
            };
    }
    var e$2 = deck._0;
    return {
            TAG: "Error",
            _0: {
              path: ".deck" + e$2.path,
              message: e$2.message,
              value: e$2.value
            }
          };
  };
  var useGame = function (subscribe, getInitial) {
    var match = React.useState(function () {
          return getInitial();
        });
    var setExternalState = match[1];
    React.useEffect((function () {
            var unsubscribe = subscribe(setExternalState);
            return (function () {
                      unsubscribe();
                    });
          }), []);
    return match[0];
  };
  var GameBase$Create$BoardWrapper = function (props) {
    var restartGame = props.restartGame;
    var undo = props.undo;
    var moveToState = props.moveToState;
    var game = useGame(props.subscribe, props.getGame);
    var undo$1 = function () {
      undo();
      moveToState();
    };
    var restartGame$1 = function () {
      restartGame();
      moveToState();
    };
    var isWin = GameRules.winCheck(game);
    return JsxRuntime.jsxs(React.Fragment, {
                children: [
                  JsxRuntime.jsx(Common.UtilBoard.make, {
                        undo: undo$1,
                        isWin: isWin,
                        createNewGame: props.createNewGame,
                        restartGame: restartGame$1
                      }),
                  JsxRuntime.jsx(GameRules.Board.make, {
                        setRef: props.setRef,
                        onMouseDown: props.onMouseDown,
                        setGame: props.setGame,
                        moveToState: moveToState,
                        autoProgress: props.autoProgress,
                        game: game,
                        undo: undo$1,
                        isWin: isWin
                      })
                ]
              });
  };
  var BoardWrapper = {
    make: GameBase$Create$BoardWrapper
  };
  var GameBase$Create$Main = function (props) {
    var setState = props.setState;
    var getState = props.getState;
    var listeners = {
      contents: new Set()
    };
    var subscribe = function (listener) {
      listeners.contents.add(listener);
      return function () {
        listeners.contents.delete(listener);
      };
    };
    var getGame = function () {
      return getState().history[getState().history.length - 1 | 0].game;
    };
    var setGame = function (f) {
      setState(function (state) {
            var newGame = f(getGame());
            listeners.contents.forEach(function (listener) {
                  listener(function (param) {
                        return newGame;
                      });
                });
            return {
                    deck: state.deck,
                    history: state.history.concat([{
                            game: newGame,
                            actor: "Auto"
                          }]),
                    undoStats: state.undoStats.currentUndoDepth > 0 ? ({
                          currentUndoDepth: 0,
                          undos: state.undoStats.undos.concat([state.undoStats.currentUndoDepth])
                        }) : state.undoStats
                  };
          });
    };
    var snapshot = function () {
      setState(function (state) {
            return {
                    deck: state.deck,
                    history: Common.ArrayAux.update(state.history, state.history.length - 1 | 0, (function (v) {
                            return {
                                    game: v.game,
                                    actor: "User"
                                  };
                          })),
                    undoStats: state.undoStats
                  };
          });
    };
    var undo = function () {
      if (getState().history.filter(function (v) {
              return v.actor === "User";
            }).length > 1) {
        return setState(function (state) {
                    var newHistory = Common.ArrayAux.sliceBefore(state.history, (function (v) {
                            return v.actor === "User";
                          }));
                    var init = state.undoStats;
                    return {
                            deck: state.deck,
                            history: newHistory,
                            undoStats: {
                              currentUndoDepth: state.undoStats.currentUndoDepth + 1 | 0,
                              undos: init.undos
                            }
                          };
                  });
      }
      
    };
    var restartGame = function () {
      setState(function (state) {
            return {
                    deck: state.deck,
                    history: state.history.slice(0, 1),
                    undoStats: {
                      currentUndoDepth: 0,
                      undos: []
                    }
                  };
          });
    };
    var refs = React.useRef([]);
    var dragData = React.useRef(undefined);
    var getElement = function (a) {
      return refs.current.find(function (el) {
                  return Caml_obj.equal(GameRules.getSpace(el), Caml_option.some(a));
                });
    };
    var setRef = function (card) {
      return function (element) {
        if (element === null || element === undefined) {
          return ;
        }
        element.id = GameRules.spaceToString(card);
        refs.current.push(element);
      };
    };
    var applyMoveToOthers = function (element, f) {
      Core__Option.mapOr(GameRules.getSpace(element), undefined, (function (space) {
              var appliedF = function (s) {
                Core__Option.mapOr(getElement(s), undefined, (function (childEl) {
                        f(childEl);
                      }));
              };
              Core__Option.mapOr(GameRules.getRule(getGame(), space), undefined, (function (rule) {
                      if (rule.TAG === "Movable") {
                        return rule._0.applyMoveToOthers(appliedF);
                      }
                      
                    }));
            }));
    };
    var liftUp = function (element, zIndex) {
      element.style["z-index"] = zIndex.toString();
      applyMoveToOthers(element, (function (childEl) {
              liftUp(childEl, zIndex + 1 | 0);
            }));
    };
    var setDown = function (element, zIndex) {
      Core__Option.mapOr(zIndex, undefined, (function (zIndex) {
              element.style["z-index"] = zIndex.toString();
            }));
      applyMoveToOthers(element, (function (childEl) {
              setDown(childEl, Core__Option.map(zIndex, (function (zIndex) {
                          return zIndex + 1 | 0;
                        })));
            }));
    };
    var move = function (element, left, top, offset) {
      element.style.left = left.toString() + "px";
      element.style.top = top.toString() + "px";
      Core__Option.mapOr(offset, undefined, (function (param) {
              var topOffset = param[1];
              var leftOffset = param[0];
              applyMoveToOthers(element, (function (childEl) {
                      move(childEl, left + leftOffset | 0, top + topOffset | 0, offset);
                    }));
            }));
    };
    var moveToState = function () {
      refs.current.forEach(function (element) {
            Core__Option.mapOr(Core__Option.flatMap(GameRules.getSpace(element), (function (space) {
                        return GameRules.getRule(getGame(), space);
                      })), undefined, (function (rule) {
                    if (rule.TAG !== "Movable") {
                      return ;
                    }
                    var match = rule._0;
                    var locationAdjustment = match.locationAdjustment;
                    Core__Option.mapOr(getElement(match.baseSpace), undefined, (function (baseElement) {
                            var basePos = elementPosition(baseElement);
                            var targetLeft = locationAdjustment.x;
                            var targetTop = locationAdjustment.y;
                            var targetZIndex = locationAdjustment.z;
                            var offset;
                            var duration = 300;
                            var start = elementPosition(element);
                            var startZIndex = zIndexFromElement(element);
                            var boardPos = Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
                                  top: 0,
                                  right: 0,
                                  bottom: 0,
                                  left: 0
                                }, (function (board) {
                                    return elementPosition(board);
                                  }));
                            var start_top = start.top - boardPos.top;
                            var start_right = start.right - boardPos.right;
                            var start_bottom = start.bottom - boardPos.bottom;
                            var start_left = start.left - boardPos.left;
                            var adjustedTargetLeft = targetLeft + basePos.left - boardPos.left;
                            var adjustedTargetTop = targetTop + basePos.top - boardPos.top;
                            var startTime = performance.now();
                            var step = function (currentTime) {
                              var elapsedTime = currentTime - startTime;
                              var progress = Math.min(elapsedTime / duration, 1);
                              var easedProgress = easeOutQuad(progress);
                              var leftMove = start_left + (adjustedTargetLeft - start_left) * easedProgress;
                              var topMove = start_top + (adjustedTargetTop - start_top) * easedProgress;
                              move(element, leftMove | 0, topMove | 0, offset);
                              if (progress < 1) {
                                requestAnimationFrame(step);
                                return ;
                              } else {
                                return setDown(element, targetZIndex);
                              }
                            };
                            if (start_left !== Math.floor(adjustedTargetLeft) || start_top !== Math.floor(adjustedTargetTop) || Caml_obj.notequal(startZIndex, targetZIndex)) {
                              liftUp(element, 1000 + Core__Option.getOr(targetZIndex, 0) | 0);
                              requestAnimationFrame(step);
                              return ;
                            }
                            
                          }));
                  }));
          });
    };
    var getBoardPos = function () {
      return Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
                }, (function (board) {
                    return elementPosition(board);
                  }));
    };
    var getOverlap = function (aEl, bEl) {
      var aPos = elementPosition(aEl);
      var bPos = elementPosition(bEl);
      var overlapX = Math.max(0, Math.min(aPos.right, bPos.right) - Math.max(aPos.left, bPos.left));
      var overlapY = Math.max(0, Math.min(aPos.bottom, bPos.bottom) - Math.max(aPos.top, bPos.top));
      return overlapX * overlapY;
    };
    var onMouseDown = function ($$event) {
      var dragElement = $$event.currentTarget;
      Core__Option.mapOr(GameRules.getSpace(dragElement), undefined, (function (dragSpace) {
              Core__Option.mapOr(GameRules.getRule(getGame(), dragSpace), undefined, (function (rule) {
                      if (rule.TAG === "Movable") {
                        return Core__Option.mapOr(rule._0.dragPile(), undefined, (function (dragPile) {
                                      var boardPos = getBoardPos();
                                      var eventPos = elementPosition($$event.currentTarget);
                                      dragData.current = {
                                        dragElement: dragElement,
                                        offset: [
                                          ($$event.clientX - (eventPos.left | 0) | 0) + (boardPos.left | 0) | 0,
                                          ($$event.clientY - (eventPos.top | 0) | 0) + (boardPos.top | 0) | 0
                                        ],
                                        dragSpace: dragSpace,
                                        dragPile: dragPile
                                      };
                                      liftUp(dragElement, 1000);
                                    }));
                      }
                      
                    }));
            }));
    };
    var onMouseMove = function ($$event) {
      Core__Option.mapOr(dragData.current, undefined, (function (dragData) {
              var match = dragData.offset;
              var leftMove = $$event.clientX - match[0] | 0;
              var topMove = $$event.clientY - match[1] | 0;
              move(dragData.dragElement, leftMove, topMove, [
                    0,
                    20
                  ]);
            }));
    };
    var autoProgress = function () {
      condInterval((function () {
              moveToState();
            }), 300, (function () {
              var dragPiles = Core__Array.filterMap(refs.current, (function (el) {
                      return Core__Option.mapOr(Core__Option.flatMap(GameRules.getSpace(el), (function (elSpace) {
                                        return GameRules.getRule(getGame(), elSpace);
                                      })), undefined, (function (rule) {
                                    if (rule.TAG !== "Movable") {
                                      return ;
                                    }
                                    var dragPile = rule._0.autoProgress();
                                    if (typeof dragPile !== "object") {
                                      return ;
                                    } else {
                                      return Caml_option.some(dragPile._0);
                                    }
                                  }));
                    }));
              var droppedUpons = Core__Array.filterMap(refs.current, (function (el) {
                      return Core__Option.mapOr(Core__Option.flatMap(GameRules.getSpace(el), (function (elSpace) {
                                        return GameRules.getRule(getGame(), elSpace);
                                      })), undefined, (function (rule) {
                                    if (rule.TAG === "Movable") {
                                      var match = rule._0;
                                      var match$1 = match.autoProgress();
                                      if (typeof match$1 !== "object" && match$1 === "Seek") {
                                        return match.droppedUpon;
                                      } else {
                                        return ;
                                      }
                                    }
                                    var match$2 = rule._0;
                                    if (match$2.autoProgress) {
                                      return match$2.droppedUpon;
                                    }
                                    
                                  }));
                    }));
              var op = {
                contents: undefined
              };
              dragPiles.forEach(function (dragPile) {
                    droppedUpons.forEach(function (droppedUpon) {
                          if (Core__Option.isNone(op.contents)) {
                            op.contents = droppedUpon(GameRules.removeDragFromGame(getGame(), dragPile), dragPile);
                            return ;
                          }
                          
                        });
                  });
              var game = op.contents;
              if (game === undefined) {
                return false;
              }
              var game$1 = Caml_option.valFromOption(game);
              setGame(function (param) {
                    return game$1;
                  });
              return true;
            }));
    };
    var onMouseUp = function (param) {
      var match = dragData.current;
      if (match !== undefined) {
        var dragPile = match.dragPile;
        var dragElement = match.dragElement;
        var greatestOverlap = {
          contents: 0
        };
        var updatedGame = {
          contents: undefined
        };
        refs.current.forEach(function (el) {
              Core__Option.mapOr(Core__Option.flatMap(Core__Option.flatMap(GameRules.getSpace(el), (function (elSpace) {
                              return GameRules.getRule(getGame(), elSpace);
                            })), (function (rule) {
                          var droppedUpon;
                          droppedUpon = rule.TAG === "Movable" ? rule._0.droppedUpon : rule._0.droppedUpon;
                          return droppedUpon(GameRules.removeDragFromGame(getGame(), dragPile), dragPile);
                        })), undefined, (function (newGame) {
                      var overlap = getOverlap(el, dragElement);
                      if (overlap > greatestOverlap.contents) {
                        greatestOverlap.contents = overlap;
                        updatedGame.contents = Caml_option.some(newGame);
                        return ;
                      }
                      
                    }));
            });
        Core__Option.mapOr(updatedGame.contents, undefined, (function (updatedGame) {
                setGame(function (param) {
                      return updatedGame;
                    });
                snapshot();
              }));
        moveToState();
        autoProgress();
      }
      dragData.current = undefined;
    };
    React.useEffect((function () {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            moveToState();
            autoProgress();
          }), []);
    return JsxRuntime.jsxs("div", {
                children: [
                  JsxRuntime.jsx(GameBase$Create$BoardWrapper, {
                        subscribe: subscribe,
                        getGame: getGame,
                        setRef: setRef,
                        onMouseDown: onMouseDown,
                        setGame: setGame,
                        moveToState: moveToState,
                        autoProgress: autoProgress,
                        undo: undo,
                        createNewGame: props.createNewGame,
                        restartGame: restartGame
                      }),
                  JsxRuntime.jsx(GameRules.AllCards.make, {
                        setRef: setRef,
                        onMouseDown: onMouseDown,
                        deck: getState().deck
                      })
                ],
                className: "relative m-5 mt-0",
                id: "board"
              });
  };
  var Main = {
    make: GameBase$Create$Main
  };
  var GameBase$Create = function (props) {
    var onCreateNewGame = props.onCreateNewGame;
    var getState = props.getState;
    var createNewGame = function () {
      var match = GameRules.initiateGame();
      var newGame_deck = match[0];
      var newGame_history = [{
          game: match[1],
          actor: "User"
        }];
      var newGame_undoStats = {
        currentUndoDepth: 0,
        undos: []
      };
      var newGame = {
        deck: newGame_deck,
        history: newGame_history,
        undoStats: newGame_undoStats
      };
      onCreateNewGame(newGame);
    };
    React.useEffect((function () {
            if (Core__Option.isNone(getState)) {
              createNewGame();
            }
            
          }), []);
    if (getState !== undefined) {
      return JsxRuntime.jsx(GameBase$Create$Main, {
                  getState: getState,
                  setState: props.setState,
                  createNewGame: createNewGame
                });
    } else {
      return null;
    }
  };
  return {
          appendReactElement: appendReactElement,
          zIndexFromElement: zIndexFromElement,
          historySnapshot_encode: historySnapshot_encode,
          historySnapshot_decode: historySnapshot_decode,
          elementPosition: elementPosition,
          eventPosition: eventPosition,
          undoStats_encode: undoStats_encode,
          undoStats_decode: undoStats_decode,
          state_encode: state_encode,
          state_decode: state_decode,
          useGame: useGame,
          BoardWrapper: BoardWrapper,
          Main: Main,
          make: GameBase$Create
        };
}

export {
  condInterval ,
  easeOutQuad ,
  stateActor_encode ,
  stateActor_decode ,
  Create ,
}
/* react Not a pure module */
