// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Common from "./Common.res.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as OtherJs from "./other.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function condInterval(prim0, prim1, prim2) {
  OtherJs.condInterval(prim0, prim1, prim2);
}

function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}

function GameBase(GameRules) {
  var appendReactElement = function (prim0, prim1) {
    OtherJs.appendReactElement(prim0, prim1);
  };
  var zIndexFromElement = function (element) {
    return Core__Int.fromString(element.style["z-index"], undefined);
  };
  var elementPosition = function (element) {
    var a = element.getBoundingClientRect();
    return {
            top: a.top,
            right: a.right,
            bottom: a.bottom,
            left: a.left
          };
  };
  var eventPosition = function ($$event) {
    return elementPosition($$event.currentTarget);
  };
  var undoStats = {
    contents: {
      currentUndoDepth: 0,
      undos: []
    }
  };
  var state = {
    contents: {
      history: [{
          game: GameRules.initiateGame(),
          actor: "User"
        }]
    }
  };
  var listeners = new Set();
  var subscribe = function (listener) {
    listeners.add(listener);
    return function () {
      listeners.delete(listener);
    };
  };
  var setUndoStats = function (f) {
    undoStats.contents = f(undoStats.contents);
  };
  var setState = function (f) {
    state.contents = f(state.contents);
  };
  var getGame = function () {
    return state.contents.history[state.contents.history.length - 1 | 0].game;
  };
  var setGame = function (f) {
    if (undoStats.contents.currentUndoDepth > 0) {
      setUndoStats(function (undoStats) {
            return {
                    currentUndoDepth: 0,
                    undos: undoStats.undos.concat([undoStats.currentUndoDepth])
                  };
          });
    }
    setState(function (state) {
          var newGame = f(getGame());
          listeners.forEach(function (listener) {
                listener(function (param) {
                      return newGame;
                    });
              });
          return {
                  history: state.history.concat([{
                          game: newGame,
                          actor: "Auto"
                        }])
                };
        });
  };
  var snapshot = function () {
    setState(function (state) {
          return {
                  history: Common.ArrayAux.update(state.history, state.history.length - 1 | 0, (function (v) {
                          return {
                                  game: v.game,
                                  actor: "User"
                                };
                        }))
                };
        });
  };
  var undo = function () {
    if (state.contents.history.filter(function (v) {
            return v.actor === "User";
          }).length > 1) {
      setState(function (state) {
            var newHistory = Common.ArrayAux.sliceBefore(state.history, (function (v) {
                    return v.actor === "User";
                  }));
            return {
                    history: newHistory
                  };
          });
      return setUndoStats(function (undoStats) {
                  return {
                          currentUndoDepth: undoStats.currentUndoDepth + 1 | 0,
                          undos: undoStats.undos
                        };
                });
    }
    
  };
  var useGame = function () {
    var match = React.useState(function () {
          return getGame();
        });
    var setExternalState = match[1];
    React.useEffect((function () {
            var unsubscribe = subscribe(setExternalState);
            return (function () {
                      unsubscribe();
                    });
          }), []);
    return match[0];
  };
  var GameBase$GameBase$BoardWrapper = function (props) {
    var undo = props.undo;
    var moveToState = props.moveToState;
    var game = useGame();
    var undo$1 = function () {
      undo();
      moveToState();
    };
    return JsxRuntime.jsx(GameRules.Board.make, {
                setRef: props.setRef,
                onMouseDown: props.onMouseDown,
                setGame: props.setGame,
                moveToState: moveToState,
                autoProgress: props.autoProgress,
                game: game,
                undo: undo$1
              });
  };
  var BoardWrapper = {
    make: GameBase$GameBase$BoardWrapper
  };
  var GameBase$GameBase = function (props) {
    var refs = React.useRef([]);
    var dragCard = React.useRef(undefined);
    var offset = React.useRef([
          0,
          0
        ]);
    var originalData = React.useRef(undefined);
    var getElement = function (a) {
      return refs.current.find(function (el) {
                  return Caml_obj.equal(GameRules.getSpace(el), Caml_option.some(a));
                });
    };
    var setRef = function (card) {
      return function (element) {
        if (element === null || element === undefined) {
          return ;
        }
        element.id = GameRules.spaceToString(card);
        refs.current.push(element);
      };
    };
    var applyMoveToOthers = function (element, f) {
      Core__Option.mapOr(GameRules.getSpace(element), undefined, (function (space) {
              var appliedF = function (s) {
                Core__Option.mapOr(getElement(s), undefined, (function (childEl) {
                        f(childEl);
                      }));
              };
              GameRules.applyMoveToOthers(space, getGame(), appliedF);
            }));
    };
    var liftUp = function (element, zIndex) {
      element.style["z-index"] = zIndex.toString();
      applyMoveToOthers(element, (function (childEl) {
              liftUp(childEl, zIndex + 1 | 0);
            }));
    };
    var setDown = function (element, zIndex) {
      Core__Option.mapOr(zIndex, undefined, (function (zIndex) {
              element.style["z-index"] = zIndex.toString();
            }));
      applyMoveToOthers(element, (function (childEl) {
              setDown(childEl, Core__Option.map(zIndex, (function (zIndex) {
                          return zIndex + 1 | 0;
                        })));
            }));
    };
    var move = function (element, left, top, offset) {
      element.style.left = left.toString() + "px";
      element.style.top = top.toString() + "px";
      Core__Option.mapOr(offset, undefined, (function (param) {
              var topOffset = param[1];
              var leftOffset = param[0];
              applyMoveToOthers(element, (function (childEl) {
                      move(childEl, left + leftOffset | 0, top + topOffset | 0, offset);
                    }));
            }));
    };
    var moveToState = function () {
      GameRules.getSpaceLocs(getGame()).forEach(function (param) {
            var pos = param[2];
            var match = getElement(param[0]);
            var match$1 = getElement(param[1]);
            if (match === undefined) {
              return ;
            }
            if (match$1 === undefined) {
              return ;
            }
            var refPos = elementPosition(Caml_option.valFromOption(match$1));
            var element = Caml_option.valFromOption(match);
            var targetLeft = pos.x;
            var targetTop = pos.y;
            var targetZIndex = pos.z;
            var offset;
            var duration = 300;
            var start = elementPosition(element);
            var startZIndex = zIndexFromElement(element);
            var boardPos = Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
                }, (function (board) {
                    return elementPosition(board);
                  }));
            var start_top = start.top - boardPos.top;
            var start_right = start.right - boardPos.right;
            var start_bottom = start.bottom - boardPos.bottom;
            var start_left = start.left - boardPos.left;
            var adjustedTargetLeft = targetLeft + refPos.left - boardPos.left;
            var adjustedTargetTop = targetTop + refPos.top - boardPos.top;
            var startTime = performance.now();
            var step = function (currentTime) {
              var elapsedTime = currentTime - startTime;
              var progress = Math.min(elapsedTime / duration, 1);
              var easedProgress = easeOutQuad(progress);
              var leftMove = start_left + (adjustedTargetLeft - start_left) * easedProgress;
              var topMove = start_top + (adjustedTargetTop - start_top) * easedProgress;
              move(element, leftMove | 0, topMove | 0, offset);
              if (progress < 1) {
                requestAnimationFrame(step);
                return ;
              } else {
                return setDown(element, targetZIndex);
              }
            };
            if (start_left !== Math.floor(adjustedTargetLeft) || start_top !== Math.floor(adjustedTargetTop) || Caml_obj.notequal(startZIndex, targetZIndex)) {
              liftUp(element, 1000 + Core__Option.getOr(targetZIndex, 0) | 0);
              requestAnimationFrame(step);
              return ;
            }
            
          });
    };
    var getOverlap = function (aEl, bEl) {
      var aPos = elementPosition(aEl);
      var bPos = elementPosition(bEl);
      var overlapX = Math.max(0, Math.min(aPos.right, bPos.right) - Math.max(aPos.left, bPos.left));
      var overlapY = Math.max(0, Math.min(aPos.bottom, bPos.bottom) - Math.max(aPos.top, bPos.top));
      return overlapX * overlapY;
    };
    var onMouseDown = function ($$event) {
      var eventElement = $$event.currentTarget;
      var space = GameRules.getSpace(eventElement);
      if (space === undefined) {
        return ;
      }
      if (!GameRules.canDrag(Caml_option.valFromOption(space), getGame())) {
        return ;
      }
      dragCard.current = Caml_option.some(eventElement);
      var dragCardPos = elementPosition(eventElement);
      var boardPos = Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }, (function (board) {
              return elementPosition(board);
            }));
      originalData.current = Core__Option.map(zIndexFromElement(eventElement), (function (v) {
              return [
                      dragCardPos,
                      v
                    ];
            }));
      liftUp(eventElement, 1000);
      var pos = elementPosition($$event.currentTarget);
      offset.current = [
        ($$event.clientX - (pos.left | 0) | 0) + (boardPos.left | 0) | 0,
        ($$event.clientY - (pos.top | 0) | 0) + (boardPos.top | 0) | 0
      ];
    };
    var onMouseMove = function ($$event) {
      Core__Option.mapOr(dragCard.current, undefined, (function (dragCard) {
              var match = offset.current;
              var leftMove = $$event.clientX - match[0] | 0;
              var topMove = $$event.clientY - match[1] | 0;
              move(dragCard, leftMove, topMove, [
                    0,
                    20
                  ]);
            }));
    };
    var getDragCard = function () {
      var dragCardEl = dragCard.current;
      if (dragCardEl === undefined) {
        return ;
      }
      var dragCardEl$1 = Caml_option.valFromOption(dragCardEl);
      var dragSpace = GameRules.getSpace(dragCardEl$1);
      if (dragSpace !== undefined) {
        return [
                dragCardEl$1,
                Caml_option.valFromOption(dragSpace)
              ];
      }
      
    };
    var autoProgress = function () {
      condInterval((function () {
              moveToState();
            }), 300, (function () {
              return GameRules.autoProgress(setGame);
            }));
    };
    var onMouseUp = function (param) {
      var match = getDragCard();
      if (match !== undefined) {
        var dragSpace = match[1];
        var dragCardEl = match[0];
        var dropOn = Core__Option.map(Core__Array.reduce(refs.current, undefined, (function (acc, el) {
                    return Core__Option.mapOr(GameRules.getSpace(el), acc, (function (elSpace) {
                                  if (!GameRules.canDrop(dragSpace, elSpace, getGame())) {
                                    return acc;
                                  }
                                  var overlap = getOverlap(el, dragCardEl);
                                  var $$new = [
                                    overlap,
                                    el
                                  ];
                                  if (overlap > 0 && !(acc !== undefined && acc[0] > overlap)) {
                                    return $$new;
                                  } else {
                                    return acc;
                                  }
                                }));
                  })), (function (param) {
                return param[1];
              }));
        if (dropOn !== undefined) {
          var dropOnSpace = GameRules.getSpace(Caml_option.valFromOption(dropOn));
          if (dropOnSpace !== undefined) {
            var dropOnSpace$1 = Caml_option.valFromOption(dropOnSpace);
            setGame(function (game) {
                  return GameRules.onDrop(dropOnSpace$1, dragSpace, game);
                });
            snapshot();
          }
          
        }
        moveToState();
        autoProgress();
      }
      dragCard.current = undefined;
    };
    React.useEffect((function () {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            moveToState();
            autoProgress();
          }), []);
    return JsxRuntime.jsxs("div", {
                children: [
                  JsxRuntime.jsx(GameBase$GameBase$BoardWrapper, {
                        setRef: setRef,
                        onMouseDown: onMouseDown,
                        setGame: setGame,
                        moveToState: moveToState,
                        autoProgress: autoProgress,
                        undo: undo
                      }),
                  JsxRuntime.jsx(GameRules.AllCards.make, {
                        setRef: setRef,
                        onMouseDown: onMouseDown
                      })
                ],
                className: "relative m-5",
                id: "board"
              });
  };
  return {
          appendReactElement: appendReactElement,
          zIndexFromElement: zIndexFromElement,
          elementPosition: elementPosition,
          eventPosition: eventPosition,
          undoStats: undoStats,
          state: state,
          listeners: listeners,
          subscribe: subscribe,
          setUndoStats: setUndoStats,
          setState: setState,
          getGame: getGame,
          setGame: setGame,
          snapshot: snapshot,
          undo: undo,
          useGame: useGame,
          BoardWrapper: BoardWrapper,
          make: GameBase$GameBase
        };
}

export {
  condInterval ,
  easeOutQuad ,
  GameBase ,
}
/* react Not a pure module */
