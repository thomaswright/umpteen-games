// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Common from "./Common.res.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as OtherJs from "./other.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function condInterval(prim0, prim1, prim2) {
  OtherJs.condInterval(prim0, prim1, prim2);
}

function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}

function GameBase(GameRules) {
  var appendReactElement = function (prim0, prim1) {
    OtherJs.appendReactElement(prim0, prim1);
  };
  var zIndexFromElement = function (element) {
    return Core__Int.fromString(element.style["z-index"], undefined);
  };
  var elementPosition = function (element) {
    var a = element.getBoundingClientRect();
    return {
            top: a.top,
            right: a.right,
            bottom: a.bottom,
            left: a.left
          };
  };
  var eventPosition = function ($$event) {
    return elementPosition($$event.currentTarget);
  };
  var undoStats = {
    contents: {
      currentUndoDepth: 0,
      undos: []
    }
  };
  var state = {
    contents: {
      history: [{
          game: GameRules.initiateGame(),
          actor: "User"
        }]
    }
  };
  var listeners = new Set();
  var subscribe = function (listener) {
    listeners.add(listener);
    return function () {
      listeners.delete(listener);
    };
  };
  var setUndoStats = function (f) {
    undoStats.contents = f(undoStats.contents);
  };
  var setState = function (f) {
    state.contents = f(state.contents);
  };
  var getGame = function () {
    return state.contents.history[state.contents.history.length - 1 | 0].game;
  };
  var setGame = function (f) {
    if (undoStats.contents.currentUndoDepth > 0) {
      setUndoStats(function (undoStats) {
            return {
                    currentUndoDepth: 0,
                    undos: undoStats.undos.concat([undoStats.currentUndoDepth])
                  };
          });
    }
    setState(function (state) {
          var newGame = f(getGame());
          listeners.forEach(function (listener) {
                listener(function (param) {
                      return newGame;
                    });
              });
          return {
                  history: state.history.concat([{
                          game: newGame,
                          actor: "Auto"
                        }])
                };
        });
  };
  var snapshot = function () {
    setState(function (state) {
          return {
                  history: Common.ArrayAux.update(state.history, state.history.length - 1 | 0, (function (v) {
                          return {
                                  game: v.game,
                                  actor: "User"
                                };
                        }))
                };
        });
  };
  var undo = function () {
    if (state.contents.history.filter(function (v) {
            return v.actor === "User";
          }).length > 1) {
      setState(function (state) {
            var newHistory = Common.ArrayAux.sliceBefore(state.history, (function (v) {
                    return v.actor === "User";
                  }));
            return {
                    history: newHistory
                  };
          });
      return setUndoStats(function (undoStats) {
                  return {
                          currentUndoDepth: undoStats.currentUndoDepth + 1 | 0,
                          undos: undoStats.undos
                        };
                });
    }
    
  };
  var useGame = function () {
    var match = React.useState(function () {
          return getGame();
        });
    var setExternalState = match[1];
    React.useEffect((function () {
            var unsubscribe = subscribe(setExternalState);
            return (function () {
                      unsubscribe();
                    });
          }), []);
    return match[0];
  };
  var GameBase2$GameBase$BoardWrapper = function (props) {
    var undo = props.undo;
    var moveToState = props.moveToState;
    var game = useGame();
    var undo$1 = function () {
      undo();
      moveToState();
    };
    return JsxRuntime.jsx(GameRules.Board.make, {
                setRef: props.setRef,
                onMouseDown: props.onMouseDown,
                setGame: props.setGame,
                moveToState: moveToState,
                autoProgress: props.autoProgress,
                game: game,
                undo: undo$1
              });
  };
  var BoardWrapper = {
    make: GameBase2$GameBase$BoardWrapper
  };
  var GameBase2$GameBase = function (props) {
    var refs = React.useRef([]);
    var dragData = React.useRef(undefined);
    var getElement = function (a) {
      return refs.current.find(function (el) {
                  return Caml_obj.equal(GameRules.getSpace(el), Caml_option.some(a));
                });
    };
    var setRef = function (card) {
      return function (element) {
        if (element === null || element === undefined) {
          return ;
        }
        element.id = GameRules.spaceToString(card);
        refs.current.push(element);
      };
    };
    var applyMoveToOthers = function (element, f) {
      Core__Option.mapOr(GameRules.getSpace(element), undefined, (function (space) {
              var appliedF = function (s) {
                Core__Option.mapOr(getElement(s), undefined, (function (childEl) {
                        f(childEl);
                      }));
              };
              Core__Option.mapOr(GameRules.getRule(getGame(), space), undefined, (function (rule) {
                      if (rule.TAG === "Movable") {
                        return rule._0.applyMoveToOthers(appliedF);
                      }
                      
                    }));
            }));
    };
    var liftUp = function (element, zIndex) {
      element.style["z-index"] = zIndex.toString();
      applyMoveToOthers(element, (function (childEl) {
              liftUp(childEl, zIndex + 1 | 0);
            }));
    };
    var setDown = function (element, zIndex) {
      Core__Option.mapOr(zIndex, undefined, (function (zIndex) {
              element.style["z-index"] = zIndex.toString();
            }));
      applyMoveToOthers(element, (function (childEl) {
              setDown(childEl, Core__Option.map(zIndex, (function (zIndex) {
                          return zIndex + 1 | 0;
                        })));
            }));
    };
    var move = function (element, left, top, offset) {
      element.style.left = left.toString() + "px";
      element.style.top = top.toString() + "px";
      Core__Option.mapOr(offset, undefined, (function (param) {
              var topOffset = param[1];
              var leftOffset = param[0];
              applyMoveToOthers(element, (function (childEl) {
                      move(childEl, left + leftOffset | 0, top + topOffset | 0, offset);
                    }));
            }));
    };
    var moveToState = function () {
      refs.current.forEach(function (element) {
            Core__Option.mapOr(Core__Option.flatMap(GameRules.getSpace(element), (function (space) {
                        return GameRules.getRule(getGame(), space);
                      })), undefined, (function (rule) {
                    if (rule.TAG !== "Movable") {
                      return ;
                    }
                    var match = rule._0;
                    var locationAdjustment = match.locationAdjustment;
                    Core__Option.mapOr(getElement(match.baseSpace), undefined, (function (baseElement) {
                            var basePos = elementPosition(baseElement);
                            var targetLeft = locationAdjustment.x;
                            var targetTop = locationAdjustment.y;
                            var targetZIndex = locationAdjustment.z;
                            var offset;
                            var duration = 300;
                            var start = elementPosition(element);
                            var startZIndex = zIndexFromElement(element);
                            var boardPos = Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
                                  top: 0,
                                  right: 0,
                                  bottom: 0,
                                  left: 0
                                }, (function (board) {
                                    return elementPosition(board);
                                  }));
                            var start_top = start.top - boardPos.top;
                            var start_right = start.right - boardPos.right;
                            var start_bottom = start.bottom - boardPos.bottom;
                            var start_left = start.left - boardPos.left;
                            var adjustedTargetLeft = targetLeft + basePos.left - boardPos.left;
                            var adjustedTargetTop = targetTop + basePos.top - boardPos.top;
                            var startTime = performance.now();
                            var step = function (currentTime) {
                              var elapsedTime = currentTime - startTime;
                              var progress = Math.min(elapsedTime / duration, 1);
                              var easedProgress = easeOutQuad(progress);
                              var leftMove = start_left + (adjustedTargetLeft - start_left) * easedProgress;
                              var topMove = start_top + (adjustedTargetTop - start_top) * easedProgress;
                              move(element, leftMove | 0, topMove | 0, offset);
                              if (progress < 1) {
                                requestAnimationFrame(step);
                                return ;
                              } else {
                                return setDown(element, targetZIndex);
                              }
                            };
                            if (start_left !== Math.floor(adjustedTargetLeft) || start_top !== Math.floor(adjustedTargetTop) || Caml_obj.notequal(startZIndex, targetZIndex)) {
                              liftUp(element, 1000 + Core__Option.getOr(targetZIndex, 0) | 0);
                              requestAnimationFrame(step);
                              return ;
                            }
                            
                          }));
                  }));
          });
    };
    var getBoardPos = function () {
      return Core__Option.mapOr(Caml_option.nullable_to_opt(document.getElementById("board")), {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
                }, (function (board) {
                    return elementPosition(board);
                  }));
    };
    var getOverlap = function (aEl, bEl) {
      var aPos = elementPosition(aEl);
      var bPos = elementPosition(bEl);
      var overlapX = Math.max(0, Math.min(aPos.right, bPos.right) - Math.max(aPos.left, bPos.left));
      var overlapY = Math.max(0, Math.min(aPos.bottom, bPos.bottom) - Math.max(aPos.top, bPos.top));
      return overlapX * overlapY;
    };
    var onMouseDown = function ($$event) {
      var dragElement = $$event.currentTarget;
      Core__Option.mapOr(GameRules.getSpace(dragElement), undefined, (function (dragSpace) {
              Core__Option.mapOr(GameRules.getRule(getGame(), dragSpace), undefined, (function (rule) {
                      if (rule.TAG !== "Movable") {
                        return ;
                      }
                      Core__Option.mapOr(rule._0.dragPile(), undefined, (function (dragPile) {
                              var boardPos = getBoardPos();
                              var eventPos = elementPosition($$event.currentTarget);
                              dragData.current = {
                                dragElement: dragElement,
                                offset: [
                                  ($$event.clientX - (eventPos.left | 0) | 0) + (boardPos.left | 0) | 0,
                                  ($$event.clientY - (eventPos.top | 0) | 0) + (boardPos.top | 0) | 0
                                ],
                                dragSpace: dragSpace,
                                dragPile: dragPile
                              };
                            }));
                      liftUp(dragElement, 1000);
                    }));
            }));
    };
    var onMouseMove = function ($$event) {
      Core__Option.mapOr(dragData.current, undefined, (function (dragData) {
              var match = dragData.offset;
              var leftMove = $$event.clientX - match[0] | 0;
              var topMove = $$event.clientY - match[1] | 0;
              move(dragData.dragElement, leftMove, topMove, [
                    0,
                    20
                  ]);
            }));
    };
    var autoProgress = function () {
      condInterval((function () {
              moveToState();
            }), 300, (function () {
              var dragPiles = Core__Array.filterMap(refs.current, (function (el) {
                      return Core__Option.mapOr(Core__Option.flatMap(GameRules.getSpace(el), (function (elSpace) {
                                        return GameRules.getRule(getGame(), elSpace);
                                      })), undefined, (function (rule) {
                                    if (rule.TAG !== "Movable") {
                                      return ;
                                    }
                                    var dragPile = rule._0.autoProgress();
                                    if (typeof dragPile !== "object") {
                                      return ;
                                    } else {
                                      return Caml_option.some(dragPile._0);
                                    }
                                  }));
                    }));
              var droppedUpons = Core__Array.filterMap(refs.current, (function (el) {
                      return Core__Option.mapOr(Core__Option.flatMap(GameRules.getSpace(el), (function (elSpace) {
                                        return GameRules.getRule(getGame(), elSpace);
                                      })), undefined, (function (rule) {
                                    if (rule.TAG === "Movable") {
                                      var match = rule._0;
                                      var match$1 = match.autoProgress();
                                      if (typeof match$1 !== "object" && match$1 === "Seek") {
                                        return match.droppedUpon;
                                      } else {
                                        return ;
                                      }
                                    }
                                    var match$2 = rule._0;
                                    if (match$2.autoProgress) {
                                      return match$2.droppedUpon;
                                    }
                                    
                                  }));
                    }));
              var op = {
                contents: undefined
              };
              dragPiles.forEach(function (dragPile) {
                    droppedUpons.forEach(function (droppedUpon) {
                          if (Core__Option.isNone(op.contents)) {
                            op.contents = droppedUpon(GameRules.removeDragFromGame(getGame(), dragPile), dragPile);
                            return ;
                          }
                          
                        });
                  });
              var game = op.contents;
              if (game === undefined) {
                return false;
              }
              var game$1 = Caml_option.valFromOption(game);
              setGame(function (param) {
                    return game$1;
                  });
              return true;
            }));
    };
    var onMouseUp = function (param) {
      var match = dragData.current;
      if (match !== undefined) {
        var dragPile = match.dragPile;
        var dragElement = match.dragElement;
        var greatestOverlap = {
          contents: 0
        };
        var updatedGame = {
          contents: undefined
        };
        refs.current.forEach(function (el) {
              Core__Option.mapOr(Core__Option.flatMap(Core__Option.flatMap(GameRules.getSpace(el), (function (elSpace) {
                              return GameRules.getRule(getGame(), elSpace);
                            })), (function (rule) {
                          var droppedUpon;
                          droppedUpon = rule.TAG === "Movable" ? rule._0.droppedUpon : rule._0.droppedUpon;
                          return droppedUpon(GameRules.removeDragFromGame(getGame(), dragPile), dragPile);
                        })), undefined, (function (newGame) {
                      var overlap = getOverlap(el, dragElement);
                      if (overlap > greatestOverlap.contents) {
                        greatestOverlap.contents = overlap;
                        updatedGame.contents = Caml_option.some(newGame);
                        return ;
                      }
                      
                    }));
            });
        Core__Option.mapOr(updatedGame.contents, undefined, (function (updatedGame) {
                setGame(function (param) {
                      return updatedGame;
                    });
                snapshot();
              }));
        moveToState();
        autoProgress();
      }
      dragData.current = undefined;
    };
    React.useEffect((function () {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            moveToState();
            autoProgress();
          }), []);
    return JsxRuntime.jsxs("div", {
                children: [
                  JsxRuntime.jsx(GameBase2$GameBase$BoardWrapper, {
                        setRef: setRef,
                        onMouseDown: onMouseDown,
                        setGame: setGame,
                        moveToState: moveToState,
                        autoProgress: autoProgress,
                        undo: undo
                      }),
                  JsxRuntime.jsx(GameRules.AllCards.make, {
                        setRef: setRef,
                        onMouseDown: onMouseDown
                      })
                ],
                className: "relative m-5",
                id: "board"
              });
  };
  return {
          appendReactElement: appendReactElement,
          zIndexFromElement: zIndexFromElement,
          elementPosition: elementPosition,
          eventPosition: eventPosition,
          undoStats: undoStats,
          state: state,
          listeners: listeners,
          subscribe: subscribe,
          setUndoStats: setUndoStats,
          setState: setState,
          getGame: getGame,
          setGame: setGame,
          snapshot: snapshot,
          undo: undo,
          useGame: useGame,
          BoardWrapper: BoardWrapper,
          make: GameBase2$GameBase
        };
}

export {
  condInterval ,
  easeOutQuad ,
  GameBase ,
}
/* react Not a pure module */
