// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as Tarot from "./Tarot.res.mjs";
import * as React from "react";
import * as Common from "./Common.res.mjs";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as GameBase from "./GameBase.res.mjs";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

var Item = {};

function item_encode(value) {
  if (value.TAG === "Card") {
    return [
            "Card",
            Card.card_encode(value._0)
          ];
  } else {
    return [
            "Tarot",
            Tarot.card_encode(value._0)
          ];
  }
}

function item_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Tarot" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Tarot.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Tarot",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function space_encode(value) {
  if (typeof value !== "object") {
    switch (value) {
      case "TarotUp" :
          return ["TarotUp"];
      case "TarotDown" :
          return ["TarotDown"];
      case "Free" :
          return ["Free"];
      
    }
  } else {
    switch (value.TAG) {
      case "Item" :
          return [
                  "Item",
                  item_encode(value._0)
                ];
      case "Foundation" :
          return [
                  "Foundation",
                  Decco.intToJson(value._0)
                ];
      case "Pile" :
          return [
                  "Pile",
                  Decco.intToJson(value._0)
                ];
      
    }
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Free" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Free"
                  };
          }
      case "Item" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = item_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Item",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "TarotDown" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "TarotDown"
                  };
          }
      case "TarotUp" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "TarotUp"
                  };
          }
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

var fullDeck = Core__Array.toShuffled(Card.getShuffledDeck().map(function (card) {
            return {
                    TAG: "Card",
                    _0: card
                  };
          }).concat(Tarot.getShuffledDeck().map(function (card) {
              return {
                      TAG: "Tarot",
                      _0: card
                    };
            })));

var deckToDeal = fullDeck.filter(function (card) {
      if (card.TAG === "Card") {
        return card._0.rank !== "RA";
      } else {
        return true;
      }
    });

function initiateGame() {
  return {
          piles: [
            deckToDeal.slice(0, 7),
            deckToDeal.slice(7, 14),
            deckToDeal.slice(14, 21),
            deckToDeal.slice(21, 28),
            deckToDeal.slice(28, 35),
            [],
            deckToDeal.slice(35, 42),
            deckToDeal.slice(42, 49),
            deckToDeal.slice(49, 56),
            deckToDeal.slice(56, 63),
            deckToDeal.slice(63, 70)
          ],
          foundations: [
            [{
                suit: "Clubs",
                rank: "RA"
              }],
            [{
                suit: "Diamonds",
                rank: "RA"
              }],
            [{
                suit: "Hearts",
                rank: "RA"
              }],
            [{
                suit: "Spades",
                rank: "RA"
              }]
          ],
          tarotUp: [],
          tarotDown: [],
          free: undefined,
          gameEnded: false
        };
}

function getSpaceLocs(game) {
  var cards = {
    contents: []
  };
  var addToCards = function (card) {
    cards.contents = cards.contents.concat([card]);
  };
  Common.ArrayAux.forEach2(game.piles, (function (param, item, i, j) {
          addToCards([
                {
                  TAG: "Item",
                  _0: item
                },
                {
                  TAG: "Pile",
                  _0: i
                },
                {
                  x: 0,
                  y: Math.imul(j, 20),
                  z: j + 1 | 0
                }
              ]);
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (param, card, i, j) {
          addToCards([
                {
                  TAG: "Item",
                  _0: {
                    TAG: "Card",
                    _0: card
                  }
                },
                {
                  TAG: "Foundation",
                  _0: i
                },
                {
                  x: 0,
                  y: 0,
                  z: j + 1 | 0
                }
              ]);
        }));
  Core__Option.mapOr(game.free, undefined, (function (item) {
          addToCards([
                {
                  TAG: "Item",
                  _0: item
                },
                "Free",
                {
                  x: 0,
                  y: 0,
                  z: 1
                }
              ]);
        }));
  game.tarotUp.forEach(function (tarot, i) {
        addToCards([
              {
                TAG: "Item",
                _0: {
                  TAG: "Tarot",
                  _0: tarot
                }
              },
              "TarotUp",
              {
                x: Math.imul(10, i),
                y: 0,
                z: i
              }
            ]);
      });
  game.tarotDown.forEach(function (tarot, i) {
        addToCards([
              {
                TAG: "Item",
                _0: {
                  TAG: "Tarot",
                  _0: tarot
                }
              },
              "TarotDown",
              {
                x: Math.imul(-10, i),
                y: 0,
                z: i
              }
            ]);
      });
  return cards.contents;
}

function baseSpace(dropItem, game) {
  var base = {
    contents: undefined
  };
  Common.ArrayAux.forEach2(game.piles, (function (param, item, i, param$1) {
          if (Caml_obj.equal(item, dropItem)) {
            base.contents = {
              TAG: "Pile",
              _0: i
            };
            return ;
          }
          
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (param, card, i, param$1) {
          if (Caml_obj.equal({
                  TAG: "Card",
                  _0: card
                }, dropItem)) {
            base.contents = {
              TAG: "Foundation",
              _0: i
            };
            return ;
          }
          
        }));
  Core__Option.mapOr(game.free, undefined, (function (card) {
          if (Caml_obj.equal(card, dropItem)) {
            base.contents = "Free";
            return ;
          }
          
        }));
  game.tarotUp.forEach(function (tarot, param) {
        if (Caml_obj.equal({
                TAG: "Tarot",
                _0: tarot
              }, dropItem)) {
          base.contents = "TarotUp";
          return ;
        }
        
      });
  game.tarotDown.forEach(function (tarot, param) {
        if (Caml_obj.equal({
                TAG: "Tarot",
                _0: tarot
              }, dropItem)) {
          base.contents = "TarotDown";
          return ;
        }
        
      });
  return base.contents;
}

function canDrag(space, game) {
  if (typeof space !== "object") {
    return false;
  }
  if (space.TAG !== "Item") {
    return false;
  }
  var item = space._0;
  var match = baseSpace(item, game);
  if (match !== undefined) {
    if (typeof match !== "object") {
      if (match === "Free") {
        return true;
      } else {
        return false;
      }
    } else if (match.TAG === "Pile") {
      return Core__Option.mapOr(Core__Option.flatMap(game.piles[match._0], (function (pile) {
                        return Common.ArrayAux.getLast(pile);
                      })), false, (function (pileLast) {
                    return Caml_obj.equal(pileLast, item);
                  }));
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function canDrop(dragSpace, dropSpace, game) {
  if (typeof dragSpace !== "object") {
    return false;
  }
  if (dragSpace.TAG !== "Item") {
    return false;
  }
  var dragItem = dragSpace._0;
  var notDragSpace = Caml_obj.notequal(dragSpace, dropSpace);
  var canBeParent;
  if (typeof dropSpace !== "object") {
    switch (dropSpace) {
      case "TarotUp" :
          canBeParent = Caml_obj.equal(dragItem, {
                TAG: "Tarot",
                _0: {
                  rank: "R1"
                }
              });
          break;
      case "TarotDown" :
          canBeParent = Caml_obj.equal(dragItem, {
                TAG: "Tarot",
                _0: {
                  rank: "R21"
                }
              });
          break;
      case "Free" :
          canBeParent = Core__Option.isNone(game.free);
          break;
      
    }
  } else {
    switch (dropSpace.TAG) {
      case "Item" :
          var dropItem = dropSpace._0;
          var match = baseSpace(dropItem, game);
          if (match !== undefined) {
            var exit = 0;
            if (typeof match !== "object") {
              if (match === "Free") {
                canBeParent = false;
              } else {
                exit = 1;
              }
            } else if (match.TAG === "Pile") {
              var topItem = Common.ArrayAux.getLast(game.piles[match._0]);
              if (Caml_obj.equal(topItem, dropItem)) {
                if (dropItem.TAG === "Card") {
                  var c1 = dropItem._0;
                  if (dragItem.TAG === "Card") {
                    var c2 = dragItem._0;
                    canBeParent = (Card.rankIsBelow(c1, c2) || Card.rankIsAbove(c1, c2)) && c1.suit === c2.suit;
                  } else {
                    canBeParent = false;
                  }
                } else {
                  var c1$1 = dropItem._0;
                  if (dragItem.TAG === "Card") {
                    canBeParent = false;
                  } else {
                    var c2$1 = dragItem._0;
                    canBeParent = Tarot.rankIsBelow(c1$1, c2$1) || Tarot.rankIsAbove(c1$1, c2$1);
                  }
                }
              } else {
                canBeParent = false;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (dropItem.TAG === "Card") {
                var c1$2 = dropItem._0;
                if (dragItem.TAG === "Card") {
                  var c2$2 = dragItem._0;
                  canBeParent = (Card.rankIsBelow(c1$2, c2$2) || Card.rankIsAbove(c1$2, c2$2)) && c1$2.suit === c2$2.suit;
                } else {
                  canBeParent = false;
                }
              } else {
                var c1$3 = dropItem._0;
                if (dragItem.TAG === "Card") {
                  canBeParent = false;
                } else {
                  var c2$3 = dragItem._0;
                  canBeParent = Tarot.rankIsBelow(c1$3, c2$3) || Tarot.rankIsAbove(c1$3, c2$3);
                }
              }
            }
            
          } else {
            canBeParent = false;
          }
          break;
      case "Foundation" :
          canBeParent = false;
          break;
      case "Pile" :
          canBeParent = game.piles[dropSpace._0].length === 0;
          break;
      
    }
  }
  if (notDragSpace) {
    return canBeParent;
  } else {
    return false;
  }
}

function onDrop(dropOnSpace, dragSpace, game) {
  if (typeof dragSpace !== "object") {
    return game;
  }
  if (dragSpace.TAG !== "Item") {
    return game;
  }
  var dragCard = dragSpace._0;
  if (dragCard.TAG === "Card") {
    var dragCard$1 = dragCard._0;
    var x = game.free;
    var gameDragRemoved_piles = game.piles.map(function (x) {
          return x.filter(function (sCard) {
                      return Caml_obj.notequal(sCard, {
                                  TAG: "Card",
                                  _0: dragCard$1
                                });
                    });
        });
    var gameDragRemoved_foundations = game.foundations;
    var gameDragRemoved_tarotUp = game.tarotUp;
    var gameDragRemoved_tarotDown = game.tarotDown;
    var gameDragRemoved_free = x !== undefined && !Caml_obj.equal(x, {
          TAG: "Card",
          _0: dragCard$1
        }) ? x : undefined;
    var gameDragRemoved_gameEnded = game.gameEnded;
    if (typeof dropOnSpace !== "object") {
      switch (dropOnSpace) {
        case "TarotUp" :
        case "TarotDown" :
            return game;
        case "Free" :
            return {
                    piles: gameDragRemoved_piles,
                    foundations: gameDragRemoved_foundations,
                    tarotUp: gameDragRemoved_tarotUp,
                    tarotDown: gameDragRemoved_tarotDown,
                    free: {
                      TAG: "Card",
                      _0: dragCard$1
                    },
                    gameEnded: gameDragRemoved_gameEnded
                  };
        
      }
    } else {
      switch (dropOnSpace.TAG) {
        case "Item" :
            var card = dropOnSpace._0;
            if (card.TAG !== "Card") {
              return game;
            }
            var card$1 = card._0;
            return {
                    piles: gameDragRemoved_piles.map(function (stack) {
                          return Common.ArrayAux.insertAfter(stack, {
                                      TAG: "Card",
                                      _0: card$1
                                    }, [{
                                        TAG: "Card",
                                        _0: dragCard$1
                                      }]);
                        }),
                    foundations: gameDragRemoved_foundations.map(function (stack) {
                          return Common.ArrayAux.insertAfter(stack, card$1, [dragCard$1]);
                        }),
                    tarotUp: gameDragRemoved_tarotUp,
                    tarotDown: gameDragRemoved_tarotDown,
                    free: gameDragRemoved_free,
                    gameEnded: gameDragRemoved_gameEnded
                  };
        case "Foundation" :
            return {
                    piles: gameDragRemoved_piles,
                    foundations: Common.ArrayAux.update(gameDragRemoved_foundations, dropOnSpace._0, (function (param) {
                            return [dragCard$1];
                          })),
                    tarotUp: gameDragRemoved_tarotUp,
                    tarotDown: gameDragRemoved_tarotDown,
                    free: gameDragRemoved_free,
                    gameEnded: gameDragRemoved_gameEnded
                  };
        case "Pile" :
            return {
                    piles: Common.ArrayAux.update(gameDragRemoved_piles, dropOnSpace._0, (function (param) {
                            return [{
                                      TAG: "Card",
                                      _0: dragCard$1
                                    }];
                          })),
                    foundations: gameDragRemoved_foundations,
                    tarotUp: gameDragRemoved_tarotUp,
                    tarotDown: gameDragRemoved_tarotDown,
                    free: gameDragRemoved_free,
                    gameEnded: gameDragRemoved_gameEnded
                  };
        
      }
    }
  } else {
    var dragTarot = dragCard._0;
    var x$1 = game.free;
    var gameDragRemoved_piles$1 = game.piles.map(function (x) {
          return x.filter(function (sCard) {
                      return Caml_obj.notequal(sCard, {
                                  TAG: "Tarot",
                                  _0: dragTarot
                                });
                    });
        });
    var gameDragRemoved_foundations$1 = game.foundations;
    var gameDragRemoved_tarotUp$1 = game.tarotUp;
    var gameDragRemoved_tarotDown$1 = game.tarotDown;
    var gameDragRemoved_free$1 = x$1 !== undefined && !Caml_obj.equal(x$1, {
          TAG: "Tarot",
          _0: dragTarot
        }) ? x$1 : undefined;
    var gameDragRemoved_gameEnded$1 = game.gameEnded;
    if (typeof dropOnSpace !== "object") {
      if (dropOnSpace === "Free") {
        return {
                piles: gameDragRemoved_piles$1,
                foundations: gameDragRemoved_foundations$1,
                tarotUp: gameDragRemoved_tarotUp$1,
                tarotDown: gameDragRemoved_tarotDown$1,
                free: {
                  TAG: "Tarot",
                  _0: dragTarot
                },
                gameEnded: gameDragRemoved_gameEnded$1
              };
      } else {
        return game;
      }
    }
    switch (dropOnSpace.TAG) {
      case "Item" :
          var tarot = dropOnSpace._0;
          if (tarot.TAG === "Card") {
            return game;
          }
          var tarot$1 = tarot._0;
          return {
                  piles: gameDragRemoved_piles$1.map(function (stack) {
                        return Common.ArrayAux.insertAfter(stack, {
                                    TAG: "Tarot",
                                    _0: tarot$1
                                  }, [{
                                      TAG: "Tarot",
                                      _0: dragTarot
                                    }]);
                      }),
                  foundations: gameDragRemoved_foundations$1,
                  tarotUp: Common.ArrayAux.insertAfter(gameDragRemoved_tarotUp$1, tarot$1, [dragTarot]),
                  tarotDown: Common.ArrayAux.insertAfter(gameDragRemoved_tarotDown$1, tarot$1, [dragTarot]),
                  free: gameDragRemoved_free$1,
                  gameEnded: gameDragRemoved_gameEnded$1
                };
      case "Pile" :
          return {
                  piles: Common.ArrayAux.update(gameDragRemoved_piles$1, dropOnSpace._0, (function (param) {
                          return [{
                                    TAG: "Tarot",
                                    _0: dragTarot
                                  }];
                        })),
                  foundations: gameDragRemoved_foundations$1,
                  tarotUp: gameDragRemoved_tarotUp$1,
                  tarotDown: gameDragRemoved_tarotDown$1,
                  free: gameDragRemoved_free$1,
                  gameEnded: gameDragRemoved_gameEnded$1
                };
      default:
        return game;
    }
  }
}

function applyMoveToOthers(space, game, move) {
  
}

function autoProgress(setGame) {
  var newGame = {
    contents: undefined
  };
  setGame(function (game) {
        game.foundations.forEach(function (foundation, i) {
              var canMove = function (c) {
                var foundationCard = Common.ArrayAux.getLast(foundation);
                if (foundationCard !== undefined) {
                  if (Card.rankIsBelow(foundationCard, c)) {
                    return foundationCard.suit === c.suit;
                  } else {
                    return false;
                  }
                } else {
                  return c.rank === "RA";
                }
              };
              Core__Option.mapOr(game.free, undefined, (function (freeItem) {
                      if (freeItem.TAG !== "Card") {
                        return ;
                      }
                      var freeCard = freeItem._0;
                      if (Core__Option.isNone(newGame.contents) && canMove(freeCard)) {
                        newGame.contents = {
                          piles: game.piles,
                          foundations: Common.ArrayAux.update(game.foundations, i, (function (f) {
                                  return f.concat([freeCard]);
                                })),
                          tarotUp: game.tarotUp,
                          tarotDown: game.tarotDown,
                          free: undefined,
                          gameEnded: game.gameEnded
                        };
                        return ;
                      }
                      
                    }));
              game.piles.forEach(function (pile, j) {
                    var match = Common.ArrayAux.getLast(pile);
                    if (match === undefined) {
                      return ;
                    }
                    if (match.TAG !== "Card") {
                      return ;
                    }
                    var pileCard = match._0;
                    if (Core__Option.isNone(newGame.contents) && canMove(pileCard)) {
                      newGame.contents = {
                        piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                                return Common.ArrayAux.removeLast(p);
                              })),
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (f) {
                                return f.concat([pileCard]);
                              })),
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: game.free,
                        gameEnded: game.gameEnded
                      };
                      return ;
                    }
                    
                  });
            });
        var canMoveTarotUp = function (tarotCard) {
          var tarotUpCard = Common.ArrayAux.getLast(game.tarotUp);
          if (tarotUpCard !== undefined) {
            return Tarot.rankIsAbove(tarotCard, tarotUpCard);
          } else {
            return tarotCard.rank === "R0";
          }
        };
        var canMoveTarotDown = function (tarotCard) {
          var tarotDownCard = Common.ArrayAux.getLast(game.tarotDown);
          if (tarotDownCard !== undefined) {
            return Tarot.rankIsBelow(tarotCard, tarotDownCard);
          } else {
            return tarotCard.rank === "R21";
          }
        };
        Core__Option.mapOr(game.free, undefined, (function (freeItem) {
                if (freeItem.TAG === "Card") {
                  return ;
                }
                var freeTarot = freeItem._0;
                if (Core__Option.isNone(newGame.contents) && canMoveTarotUp(freeTarot)) {
                  newGame.contents = {
                    piles: game.piles,
                    foundations: game.foundations,
                    tarotUp: game.tarotUp.concat([freeTarot]),
                    tarotDown: game.tarotDown,
                    free: undefined,
                    gameEnded: game.gameEnded
                  };
                }
                if (Core__Option.isNone(newGame.contents) && canMoveTarotDown(freeTarot)) {
                  newGame.contents = {
                    piles: game.piles,
                    foundations: game.foundations,
                    tarotUp: game.tarotUp,
                    tarotDown: game.tarotDown.concat([freeTarot]),
                    free: undefined,
                    gameEnded: game.gameEnded
                  };
                  return ;
                }
                
              }));
        game.piles.forEach(function (pile, j) {
              var match = Common.ArrayAux.getLast(pile);
              if (match === undefined) {
                return ;
              }
              if (match.TAG === "Card") {
                return ;
              }
              var pileTarot = match._0;
              if (Core__Option.isNone(newGame.contents) && canMoveTarotUp(pileTarot)) {
                newGame.contents = {
                  piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                          return Common.ArrayAux.removeLast(p);
                        })),
                  foundations: game.foundations,
                  tarotUp: game.tarotUp.concat([pileTarot]),
                  tarotDown: game.tarotDown,
                  free: game.free,
                  gameEnded: game.gameEnded
                };
              }
              if (Core__Option.isNone(newGame.contents) && canMoveTarotDown(pileTarot)) {
                newGame.contents = {
                  piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                          return Common.ArrayAux.removeLast(p);
                        })),
                  foundations: game.foundations,
                  tarotUp: game.tarotUp,
                  tarotDown: game.tarotDown.concat([pileTarot]),
                  free: game.free,
                  gameEnded: game.gameEnded
                };
                return ;
              }
              
            });
        return Core__Option.getOr(newGame.contents, game);
      });
  return Core__Option.isSome(newGame.contents);
}

function UpAndDown$GameRules$Board(props) {
  var undo = props.undo;
  var setRef = props.setRef;
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                JsxRuntime.jsx("div", {
                      children: JsxRuntime.jsx("button", {
                            children: "Undo",
                            onClick: (function (param) {
                                undo();
                              })
                          })
                    }),
                JsxRuntime.jsxs("div", {
                      children: [
                        JsxRuntime.jsxs("div", {
                              children: [
                                JsxRuntime.jsx("div", {
                                      children: "0",
                                      ref: Caml_option.some(setRef("TarotUp")),
                                      className: " border border-slate-300 bg-slate-200 rounded w-14 h-20 flex \n              flex-row items-center justify-center text-xl font-bold text-slate-400"
                                    }, JSON.stringify(space_encode("TarotUp"))),
                                JsxRuntime.jsx("div", {
                                      children: "21",
                                      ref: Caml_option.some(setRef("TarotDown")),
                                      className: " border border-slate-300 bg-slate-200 rounded w-14 h-20 flex \n              flex-row items-center justify-center text-xl font-bold text-slate-400"
                                    }, JSON.stringify(space_encode("TarotDown")))
                              ],
                              className: "flex flex-row justify-between",
                              style: {
                                width: "290px"
                              }
                            }),
                        JsxRuntime.jsx("div", {
                              ref: Caml_option.some(setRef("Free")),
                              className: "outline outline-2 outline-purple-300 bg-purple-100 rounded w-14 h-20 mx-10"
                            }, JSON.stringify(space_encode("Free"))),
                        JsxRuntime.jsx("div", {
                              children: [
                                  [],
                                  [],
                                  [],
                                  []
                                ].map(function (param, i) {
                                    return JsxRuntime.jsx("div", {
                                                ref: Caml_option.some(setRef({
                                                          TAG: "Foundation",
                                                          _0: i
                                                        })),
                                                className: " border  border-slate-200 bg-slate-100 rounded w-14 h-20"
                                              }, JSON.stringify(space_encode({
                                                        TAG: "Foundation",
                                                        _0: i
                                                      })));
                                  }),
                              className: "flex flex-row gap-3"
                            })
                      ],
                      className: "flex flex-row  "
                    }),
                JsxRuntime.jsx("div", {
                      children: [
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          [],
                          []
                        ].map(function (param, i) {
                            return JsxRuntime.jsx("div", {
                                        ref: Caml_option.some(setRef({
                                                  TAG: "Pile",
                                                  _0: i
                                                })),
                                        className: " border border-slate-200 bg-slate-100  rounded w-14 h-20"
                                      }, JSON.stringify(space_encode({
                                                TAG: "Pile",
                                                _0: i
                                              })));
                          }),
                      className: "flex flex-row gap-3 mt-5"
                    })
              ]
            });
}

var Board = {
  make: UpAndDown$GameRules$Board
};

function UpAndDown$GameRules$AllCards(props) {
  var onMouseDown = props.onMouseDown;
  var setRef = props.setRef;
  return JsxRuntime.jsx(React.Fragment, {
              children: fullDeck.map(function (item) {
                    if (item.TAG === "Card") {
                      return JsxRuntime.jsx(Card.Display.make, {
                                  card: item._0,
                                  id: JSON.stringify(space_encode({
                                            TAG: "Item",
                                            _0: item
                                          })),
                                  cardRef: setRef({
                                        TAG: "Item",
                                        _0: item
                                      }),
                                  onMouseDown: onMouseDown,
                                  multiColor: true
                                }, JSON.stringify(space_encode({
                                          TAG: "Item",
                                          _0: item
                                        })));
                    } else {
                      return JsxRuntime.jsx(Tarot.Display.make, {
                                  card: item._0,
                                  id: JSON.stringify(space_encode({
                                            TAG: "Item",
                                            _0: item
                                          })),
                                  cardRef: setRef({
                                        TAG: "Item",
                                        _0: item
                                      }),
                                  onMouseDown: onMouseDown
                                }, JSON.stringify(space_encode({
                                          TAG: "Item",
                                          _0: item
                                        })));
                    }
                  })
            });
}

var AllCards = {
  make: UpAndDown$GameRules$AllCards
};

var GameRules = {
  foundationOffset: 420,
  Item: Item,
  item_encode: item_encode,
  item_decode: item_decode,
  space_encode: space_encode,
  space_decode: space_decode,
  getSpace: getSpace,
  spaceToString: spaceToString,
  fullDeck: fullDeck,
  deckToDeal: deckToDeal,
  initiateGame: initiateGame,
  getSpaceLocs: getSpaceLocs,
  baseSpace: baseSpace,
  canDrag: canDrag,
  canDrop: canDrop,
  onDrop: onDrop,
  applyMoveToOthers: applyMoveToOthers,
  autoProgress: autoProgress,
  Board: Board,
  AllCards: AllCards
};

var Game = GameBase.GameBase({
      getSpace: getSpace,
      spaceToString: spaceToString,
      initiateGame: initiateGame,
      getSpaceLocs: getSpaceLocs,
      applyMoveToOthers: applyMoveToOthers,
      canDrag: canDrag,
      canDrop: canDrop,
      onDrop: onDrop,
      autoProgress: autoProgress,
      Board: Board,
      AllCards: AllCards
    });

export {
  GameRules ,
  Game ,
}
/* fullDeck Not a pure module */
