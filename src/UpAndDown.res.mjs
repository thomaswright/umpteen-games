// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.res.mjs";
import * as Decco from "@rescript-labs/decco/src/Decco.res.mjs";
import * as Tarot from "./Tarot.res.mjs";
import * as React from "react";
import * as Common from "./Common.res.mjs";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as GameBase from "./GameBase.res.mjs";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

var Item = {};

function item_encode(value) {
  if (value.TAG === "Card") {
    return [
            "Card",
            Card.card_encode(value._0)
          ];
  } else {
    return [
            "Tarot",
            Tarot.card_encode(value._0)
          ];
  }
}

function item_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Card" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Card.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Card",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Tarot" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = Tarot.card_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Tarot",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function space_encode(value) {
  if (typeof value !== "object") {
    switch (value) {
      case "TarotUp" :
          return ["TarotUp"];
      case "TarotDown" :
          return ["TarotDown"];
      case "Free" :
          return ["Free"];
      
    }
  } else {
    switch (value.TAG) {
      case "Item" :
          return [
                  "Item",
                  item_encode(value._0)
                ];
      case "Foundation" :
          return [
                  "Foundation",
                  Decco.intToJson(value._0)
                ];
      case "Pile" :
          return [
                  "Pile",
                  Decco.intToJson(value._0)
                ];
      
    }
  }
}

function space_decode(value) {
  var jsonArr = Js_json.classify(value);
  if (typeof jsonArr !== "object") {
    return Decco.error(undefined, "Not a variant", value);
  }
  if (jsonArr.TAG !== "JSONArray") {
    return Decco.error(undefined, "Not a variant", value);
  }
  var jsonArr$1 = jsonArr._0;
  if (jsonArr$1.length === 0) {
    return Decco.error(undefined, "Expected variant, found empty array", value);
  }
  var tagged = Js_array.map(Js_json.classify, jsonArr$1);
  var match = Belt_Array.getExn(tagged, 0);
  if (typeof match === "object" && match.TAG === "JSONString") {
    switch (match._0) {
      case "Foundation" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Foundation",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Free" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Free"
                  };
          }
      case "Item" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$1 = item_decode(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Item",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      case "Pile" :
          if (tagged.length !== 2) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          }
          var v0$2 = Decco.intFromJson(Belt_Array.getExn(jsonArr$1, 1));
          if (v0$2.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Pile",
                      _0: v0$2._0
                    }
                  };
          }
          var e$2 = v0$2._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$2.path,
                    message: e$2.message,
                    value: e$2.value
                  }
                };
      case "TarotDown" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "TarotDown"
                  };
          }
      case "TarotUp" :
          if (tagged.length !== 1) {
            return Decco.error(undefined, "Invalid number of arguments to variant constructor", value);
          } else {
            return {
                    TAG: "Ok",
                    _0: "TarotUp"
                  };
          }
      default:
        
    }
  }
  return Decco.error(undefined, "Invalid variant constructor", Belt_Array.getExn(jsonArr$1, 0));
}

function getSpace(element) {
  var d = space_decode(JSON.parse(element.id));
  if (d.TAG === "Ok") {
    return d._0;
  }
  
}

function spaceToString(space) {
  return JSON.stringify(space_encode(space));
}

var fullDeck = Core__Array.toShuffled(Card.getShuffledDeck().map(function (card) {
            return {
                    TAG: "Card",
                    _0: card
                  };
          }).concat(Tarot.getShuffledDeck().map(function (card) {
              return {
                      TAG: "Tarot",
                      _0: card
                    };
            })));

var deckToDeal = fullDeck.filter(function (card) {
      if (card.TAG === "Card") {
        return card._0.rank !== "RA";
      } else {
        return true;
      }
    });

function initiateGame() {
  return {
          piles: [
            deckToDeal.slice(0, 7),
            deckToDeal.slice(7, 14),
            deckToDeal.slice(14, 21),
            deckToDeal.slice(21, 28),
            deckToDeal.slice(28, 35),
            [],
            deckToDeal.slice(35, 42),
            deckToDeal.slice(42, 49),
            deckToDeal.slice(49, 56),
            deckToDeal.slice(56, 63),
            deckToDeal.slice(63, 70)
          ],
          foundations: [
            [{
                suit: "Clubs",
                rank: "RA"
              }],
            [{
                suit: "Diamonds",
                rank: "RA"
              }],
            [{
                suit: "Hearts",
                rank: "RA"
              }],
            [{
                suit: "Spades",
                rank: "RA"
              }]
          ],
          tarotUp: [],
          tarotDown: [],
          free: undefined,
          gameEnded: false
        };
}

function getSpaceLocs(game) {
  var cards = {
    contents: []
  };
  var addToCards = function (card) {
    cards.contents = cards.contents.concat([card]);
  };
  Common.ArrayAux.forEach2(game.piles, (function (param, item, i, j) {
          addToCards([
                {
                  TAG: "Item",
                  _0: item
                },
                {
                  x: Math.imul(i, 70),
                  y: 100 + Math.imul(j, 20) | 0,
                  z: j + 1 | 0
                }
              ]);
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (param, card, i, j) {
          addToCards([
                {
                  TAG: "Item",
                  _0: {
                    TAG: "Card",
                    _0: card
                  }
                },
                {
                  x: 320 + Math.imul(i, 70) | 0,
                  y: 0,
                  z: j + 1 | 0
                }
              ]);
        }));
  Core__Option.mapOr(game.free, undefined, (function (item) {
          addToCards([
                {
                  TAG: "Item",
                  _0: item
                },
                {
                  x: 250,
                  y: 0,
                  z: 1
                }
              ]);
        }));
  game.tarotUp.forEach(function (tarot, i) {
        addToCards([
              {
                TAG: "Item",
                _0: {
                  TAG: "Tarot",
                  _0: tarot
                }
              },
              {
                x: Math.imul(10, i),
                y: 0,
                z: i
              }
            ]);
      });
  game.tarotDown.forEach(function (tarot, i) {
        addToCards([
              {
                TAG: "Item",
                _0: {
                  TAG: "Tarot",
                  _0: tarot
                }
              },
              {
                x: 180 - Math.imul(10, i) | 0,
                y: 0,
                z: i
              }
            ]);
      });
  return cards.contents;
}

function baseSpace(dropItem, game) {
  var base = {
    contents: undefined
  };
  Common.ArrayAux.forEach2(game.piles, (function (param, item, i, param$1) {
          if (Caml_obj.equal(item, dropItem)) {
            base.contents = {
              TAG: "Pile",
              _0: i
            };
            return ;
          }
          
        }));
  Common.ArrayAux.forEach2(game.foundations, (function (param, card, i, param$1) {
          if (Caml_obj.equal({
                  TAG: "Card",
                  _0: card
                }, dropItem)) {
            base.contents = {
              TAG: "Foundation",
              _0: i
            };
            return ;
          }
          
        }));
  Core__Option.mapOr(game.free, undefined, (function (card) {
          if (Caml_obj.equal(card, dropItem)) {
            base.contents = "Free";
            return ;
          }
          
        }));
  game.tarotUp.forEach(function (tarot, i) {
        if (Caml_obj.equal({
                TAG: "Tarot",
                _0: tarot
              }, dropItem)) {
          base.contents = "TarotUp";
          return ;
        }
        
      });
  game.tarotDown.forEach(function (tarot, i) {
        if (Caml_obj.equal({
                TAG: "Tarot",
                _0: tarot
              }, dropItem)) {
          base.contents = "TarotDown";
          return ;
        }
        
      });
  return base.contents;
}

function canDrag(space, game) {
  if (typeof space !== "object") {
    return false;
  }
  if (space.TAG !== "Item") {
    return false;
  }
  var item = space._0;
  var match = baseSpace(item, game);
  if (match !== undefined) {
    if (typeof match !== "object") {
      if (match === "Free") {
        return true;
      } else {
        return false;
      }
    } else if (match.TAG === "Pile") {
      return Core__Option.mapOr(Core__Option.flatMap(game.piles[match._0], (function (pile) {
                        return Common.ArrayAux.getLast(pile);
                      })), false, (function (pileLast) {
                    return Caml_obj.equal(pileLast, item);
                  }));
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function canDrop(dragSpace, dropSpace, game) {
  if (typeof dragSpace !== "object") {
    return false;
  }
  if (dragSpace.TAG !== "Item") {
    return false;
  }
  var dragItem = dragSpace._0;
  var notDragSpace = Caml_obj.notequal(dragSpace, dropSpace);
  var canBeParent;
  if (typeof dropSpace !== "object") {
    switch (dropSpace) {
      case "TarotUp" :
          canBeParent = Caml_obj.equal(dragItem, {
                TAG: "Tarot",
                _0: {
                  rank: "R1"
                }
              });
          break;
      case "TarotDown" :
          canBeParent = Caml_obj.equal(dragItem, {
                TAG: "Tarot",
                _0: {
                  rank: "R21"
                }
              });
          break;
      case "Free" :
          canBeParent = Core__Option.isNone(game.free);
          break;
      
    }
  } else {
    switch (dropSpace.TAG) {
      case "Item" :
          var dropItem = dropSpace._0;
          var match = baseSpace(dropItem, game);
          if (match !== undefined) {
            var exit = 0;
            if (typeof match !== "object") {
              if (match === "Free") {
                canBeParent = false;
              } else {
                exit = 1;
              }
            } else if (match.TAG === "Pile") {
              var topItem = Common.ArrayAux.getLast(game.piles[match._0]);
              if (Caml_obj.equal(topItem, dropItem)) {
                if (dropItem.TAG === "Card") {
                  var c1 = dropItem._0;
                  if (dragItem.TAG === "Card") {
                    var c2 = dragItem._0;
                    canBeParent = Card.rankIsBelow(c1, c2) || Card.rankIsAbove(c1, c2);
                  } else {
                    canBeParent = false;
                  }
                } else {
                  var c1$1 = dropItem._0;
                  if (dragItem.TAG === "Card") {
                    canBeParent = false;
                  } else {
                    var c2$1 = dragItem._0;
                    canBeParent = Tarot.rankIsBelow(c1$1, c2$1) || Tarot.rankIsAbove(c1$1, c2$1);
                  }
                }
              } else {
                canBeParent = false;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              if (dropItem.TAG === "Card") {
                var c1$2 = dropItem._0;
                if (dragItem.TAG === "Card") {
                  var c2$2 = dragItem._0;
                  canBeParent = Card.rankIsBelow(c1$2, c2$2) || Card.rankIsAbove(c1$2, c2$2);
                } else {
                  canBeParent = false;
                }
              } else {
                var c1$3 = dropItem._0;
                if (dragItem.TAG === "Card") {
                  canBeParent = false;
                } else {
                  var c2$3 = dragItem._0;
                  canBeParent = Tarot.rankIsBelow(c1$3, c2$3) || Tarot.rankIsAbove(c1$3, c2$3);
                }
              }
            }
            
          } else {
            canBeParent = false;
          }
          break;
      case "Foundation" :
          canBeParent = false;
          break;
      case "Pile" :
          canBeParent = game.piles[dropSpace._0].length === 0;
          break;
      
    }
  }
  if (notDragSpace) {
    return canBeParent;
  } else {
    return false;
  }
}

function onDrop(dropOnSpace, dragSpace, game, setGame) {
  if (typeof dragSpace !== "object") {
    return ;
  }
  if (dragSpace.TAG !== "Item") {
    return ;
  }
  var dragCard = dragSpace._0;
  if (dragCard.TAG === "Card") {
    var dragCard$1 = dragCard._0;
    var removeDrag = function (x) {
      return x.filter(function (sCard) {
                  return Caml_obj.notequal(sCard, {
                              TAG: "Card",
                              _0: dragCard$1
                            });
                });
    };
    setGame(function (game) {
          var x = game.free;
          return {
                  piles: game.piles.map(removeDrag),
                  foundations: game.foundations,
                  tarotUp: game.tarotUp,
                  tarotDown: game.tarotDown,
                  free: x !== undefined && !Caml_obj.equal(x, {
                        TAG: "Card",
                        _0: dragCard$1
                      }) ? x : undefined,
                  gameEnded: game.gameEnded
                };
        });
    if (typeof dropOnSpace !== "object") {
      switch (dropOnSpace) {
        case "TarotUp" :
        case "TarotDown" :
            return ;
        case "Free" :
            return setGame(function (game) {
                        return {
                                piles: game.piles,
                                foundations: game.foundations,
                                tarotUp: game.tarotUp,
                                tarotDown: game.tarotDown,
                                free: {
                                  TAG: "Card",
                                  _0: dragCard$1
                                },
                                gameEnded: game.gameEnded
                              };
                      });
        
      }
    } else {
      switch (dropOnSpace.TAG) {
        case "Item" :
            var card = dropOnSpace._0;
            if (card.TAG !== "Card") {
              return ;
            }
            var card$1 = card._0;
            return setGame(function (game) {
                        return {
                                piles: game.piles.map(function (stack) {
                                      return Common.ArrayAux.insertAfter(stack, {
                                                  TAG: "Card",
                                                  _0: card$1
                                                }, [{
                                                    TAG: "Card",
                                                    _0: dragCard$1
                                                  }]);
                                    }),
                                foundations: game.foundations.map(function (stack) {
                                      return Common.ArrayAux.insertAfter(stack, card$1, [dragCard$1]);
                                    }),
                                tarotUp: game.tarotUp,
                                tarotDown: game.tarotDown,
                                free: game.free,
                                gameEnded: game.gameEnded
                              };
                      });
        case "Foundation" :
            var i = dropOnSpace._0;
            return setGame(function (game) {
                        return {
                                piles: game.piles,
                                foundations: Common.ArrayAux.update(game.foundations, i, (function (param) {
                                        return [dragCard$1];
                                      })),
                                tarotUp: game.tarotUp,
                                tarotDown: game.tarotDown,
                                free: game.free,
                                gameEnded: game.gameEnded
                              };
                      });
        case "Pile" :
            var i$1 = dropOnSpace._0;
            return setGame(function (game) {
                        return {
                                piles: Common.ArrayAux.update(game.piles, i$1, (function (param) {
                                        return [{
                                                  TAG: "Card",
                                                  _0: dragCard$1
                                                }];
                                      })),
                                foundations: game.foundations,
                                tarotUp: game.tarotUp,
                                tarotDown: game.tarotDown,
                                free: game.free,
                                gameEnded: game.gameEnded
                              };
                      });
        
      }
    }
  } else {
    var dragTarot = dragCard._0;
    var removeDrag$1 = function (x) {
      return x.filter(function (sCard) {
                  return Caml_obj.notequal(sCard, {
                              TAG: "Tarot",
                              _0: dragTarot
                            });
                });
    };
    setGame(function (game) {
          var x = game.free;
          return {
                  piles: game.piles.map(removeDrag$1),
                  foundations: game.foundations,
                  tarotUp: game.tarotUp,
                  tarotDown: game.tarotDown,
                  free: x !== undefined && !Caml_obj.equal(x, {
                        TAG: "Tarot",
                        _0: dragTarot
                      }) ? x : undefined,
                  gameEnded: game.gameEnded
                };
        });
    if (typeof dropOnSpace !== "object") {
      if (dropOnSpace === "Free") {
        return setGame(function (game) {
                    return {
                            piles: game.piles,
                            foundations: game.foundations,
                            tarotUp: game.tarotUp,
                            tarotDown: game.tarotDown,
                            free: {
                              TAG: "Tarot",
                              _0: dragTarot
                            },
                            gameEnded: game.gameEnded
                          };
                  });
      } else {
        return ;
      }
    }
    switch (dropOnSpace.TAG) {
      case "Item" :
          var tarot = dropOnSpace._0;
          if (tarot.TAG === "Card") {
            return ;
          }
          var tarot$1 = tarot._0;
          return setGame(function (game) {
                      return {
                              piles: game.piles.map(function (stack) {
                                    return Common.ArrayAux.insertAfter(stack, {
                                                TAG: "Tarot",
                                                _0: tarot$1
                                              }, [{
                                                  TAG: "Tarot",
                                                  _0: dragTarot
                                                }]);
                                  }),
                              foundations: game.foundations,
                              tarotUp: Common.ArrayAux.insertAfter(game.tarotUp, tarot$1, [dragTarot]),
                              tarotDown: Common.ArrayAux.insertAfter(game.tarotDown, tarot$1, [dragTarot]),
                              free: game.free,
                              gameEnded: game.gameEnded
                            };
                    });
      case "Pile" :
          var i$2 = dropOnSpace._0;
          return setGame(function (game) {
                      return {
                              piles: Common.ArrayAux.update(game.piles, i$2, (function (param) {
                                      return [{
                                                TAG: "Tarot",
                                                _0: dragTarot
                                              }];
                                    })),
                              foundations: game.foundations,
                              tarotUp: game.tarotUp,
                              tarotDown: game.tarotDown,
                              free: game.free,
                              gameEnded: game.gameEnded
                            };
                    });
      default:
        return ;
    }
  }
}

function applyMoveToOthers(space, game, move) {
  
}

function autoProgress(setGame) {
  var newGame = {
    contents: undefined
  };
  setGame(function (game) {
        game.foundations.forEach(function (foundation, i) {
              var canMove = function (c) {
                var foundationCard = Common.ArrayAux.getLast(foundation);
                if (foundationCard !== undefined) {
                  if (Card.rankIsBelow(foundationCard, c)) {
                    return foundationCard.suit === c.suit;
                  } else {
                    return false;
                  }
                } else {
                  return c.rank === "RA";
                }
              };
              Core__Option.mapOr(game.free, undefined, (function (freeItem) {
                      if (freeItem.TAG !== "Card") {
                        return ;
                      }
                      var freeCard = freeItem._0;
                      if (Core__Option.isNone(newGame.contents) && canMove(freeCard)) {
                        newGame.contents = {
                          piles: game.piles,
                          foundations: Common.ArrayAux.update(game.foundations, i, (function (f) {
                                  return f.concat([freeCard]);
                                })),
                          tarotUp: game.tarotUp,
                          tarotDown: game.tarotDown,
                          free: undefined,
                          gameEnded: game.gameEnded
                        };
                        return ;
                      }
                      
                    }));
              game.piles.forEach(function (pile, j) {
                    var match = Common.ArrayAux.getLast(pile);
                    if (match === undefined) {
                      return ;
                    }
                    if (match.TAG !== "Card") {
                      return ;
                    }
                    var pileCard = match._0;
                    if (Core__Option.isNone(newGame.contents) && canMove(pileCard)) {
                      newGame.contents = {
                        piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                                return Common.ArrayAux.removeLast(p);
                              })),
                        foundations: Common.ArrayAux.update(game.foundations, i, (function (f) {
                                return f.concat([pileCard]);
                              })),
                        tarotUp: game.tarotUp,
                        tarotDown: game.tarotDown,
                        free: game.free,
                        gameEnded: game.gameEnded
                      };
                      return ;
                    }
                    
                  });
            });
        if (Core__Option.isNone(newGame.contents)) {
          var canMoveTarotUp = function (tarotCard) {
            var tarotUpCard = Common.ArrayAux.getLast(game.tarotUp);
            if (tarotUpCard !== undefined) {
              return Tarot.rankIsAbove(tarotCard, tarotUpCard);
            } else {
              return tarotCard.rank === "R0";
            }
          };
          var canMoveTarotDown = function (tarotCard) {
            var tarotUpCard = Common.ArrayAux.getLast(game.tarotUp);
            if (tarotUpCard !== undefined) {
              return Tarot.rankIsBelow(tarotCard, tarotUpCard);
            } else {
              return tarotCard.rank === "R21";
            }
          };
          Core__Option.mapOr(game.free, undefined, (function (freeItem) {
                  if (freeItem.TAG === "Card") {
                    return ;
                  }
                  var freeTarot = freeItem._0;
                  if (Core__Option.isNone(newGame.contents) && canMoveTarotUp(freeTarot)) {
                    newGame.contents = {
                      piles: game.piles,
                      foundations: game.foundations,
                      tarotUp: game.tarotUp.concat([freeTarot]),
                      tarotDown: game.tarotDown,
                      free: undefined,
                      gameEnded: game.gameEnded
                    };
                  }
                  if (Core__Option.isNone(newGame.contents) && canMoveTarotDown(freeTarot)) {
                    newGame.contents = {
                      piles: game.piles,
                      foundations: game.foundations,
                      tarotUp: game.tarotUp,
                      tarotDown: game.tarotDown.concat([freeTarot]),
                      free: undefined,
                      gameEnded: game.gameEnded
                    };
                    return ;
                  }
                  
                }));
          game.piles.forEach(function (pile, j) {
                var match = Common.ArrayAux.getLast(pile);
                if (match === undefined) {
                  return ;
                }
                if (match.TAG === "Card") {
                  return ;
                }
                var pileTarot = match._0;
                if (Core__Option.isNone(newGame.contents) && canMoveTarotUp(pileTarot)) {
                  newGame.contents = {
                    piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                            return Common.ArrayAux.removeLast(p);
                          })),
                    foundations: game.foundations,
                    tarotUp: game.tarotUp.concat([pileTarot]),
                    tarotDown: game.tarotDown,
                    free: game.free,
                    gameEnded: game.gameEnded
                  };
                }
                if (Core__Option.isNone(newGame.contents) && canMoveTarotDown(pileTarot)) {
                  newGame.contents = {
                    piles: Common.ArrayAux.update(game.piles, j, (function (p) {
                            return Common.ArrayAux.removeLast(p);
                          })),
                    foundations: game.foundations,
                    tarotUp: game.tarotUp,
                    tarotDown: game.tarotUp.concat([pileTarot]),
                    free: game.free,
                    gameEnded: game.gameEnded
                  };
                  return ;
                }
                
              });
        }
        return Core__Option.getOr(newGame.contents, game);
      });
  return Core__Option.isSome(newGame.contents);
}

function UpAndDown$GameRules$Independent(props) {
  var onMouseDown = props.onMouseDown;
  var setRef = props.setRef;
  return JsxRuntime.jsxs(React.Fragment, {
              children: [
                JsxRuntime.jsx("div", {
                      ref: Caml_option.some(setRef("TarotUp")),
                      className: "absolute border border-slate-200 bg-slate-700 rounded w-14 h-20",
                      style: {
                        left: "0px",
                        top: "0px",
                        zIndex: "0"
                      }
                    }, JSON.stringify(space_encode("Free"))),
                JsxRuntime.jsx("div", {
                      ref: Caml_option.some(setRef("TarotDown")),
                      className: "absolute border border-slate-200 bg-slate-700 rounded w-14 h-20",
                      style: {
                        left: (180).toString() + "px",
                        top: "0px",
                        zIndex: "0"
                      }
                    }, JSON.stringify(space_encode("Free"))),
                JsxRuntime.jsx("div", {
                      ref: Caml_option.some(setRef("Free")),
                      className: "absolute border border-purple-200 bg-purple-100 rounded w-14 h-20",
                      style: {
                        left: (250).toString() + "px",
                        top: "0px",
                        zIndex: "0"
                      }
                    }, JSON.stringify(space_encode("Free"))),
                [
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Foundation",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100 rounded w-14 h-20",
                                  style: {
                                    left: (320 + Math.imul(i, 70) | 0).toString() + "px",
                                    top: "0px",
                                    zIndex: "0"
                                  }
                                }, JSON.stringify(space_encode({
                                          TAG: "Foundation",
                                          _0: i
                                        })));
                    }),
                [
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    [],
                    []
                  ].map(function (param, i) {
                      return JsxRuntime.jsx("div", {
                                  ref: Caml_option.some(setRef({
                                            TAG: "Pile",
                                            _0: i
                                          })),
                                  className: "absolute border border-slate-200 bg-slate-100  rounded w-14 h-20",
                                  style: {
                                    left: Math.imul(i, 70).toString() + "px",
                                    top: "100px",
                                    zIndex: "0"
                                  }
                                }, JSON.stringify(space_encode({
                                          TAG: "Pile",
                                          _0: i
                                        })));
                    }),
                fullDeck.map(function (item) {
                      if (item.TAG === "Card") {
                        return JsxRuntime.jsx(Card.Display.make, {
                                    card: item._0,
                                    id: JSON.stringify(space_encode({
                                              TAG: "Item",
                                              _0: item
                                            })),
                                    cardRef: setRef({
                                          TAG: "Item",
                                          _0: item
                                        }),
                                    onMouseDown: onMouseDown,
                                    multiColor: true
                                  }, JSON.stringify(space_encode({
                                            TAG: "Item",
                                            _0: item
                                          })));
                      } else {
                        return JsxRuntime.jsx(Tarot.Display.make, {
                                    card: item._0,
                                    id: JSON.stringify(space_encode({
                                              TAG: "Item",
                                              _0: item
                                            })),
                                    cardRef: setRef({
                                          TAG: "Item",
                                          _0: item
                                        }),
                                    onMouseDown: onMouseDown
                                  }, JSON.stringify(space_encode({
                                            TAG: "Item",
                                            _0: item
                                          })));
                      }
                    })
              ]
            });
}

var Independent = {
  make: UpAndDown$GameRules$Independent
};

function UpAndDown$GameRules$Dependent(props) {
  return null;
}

var Dependent = {
  make: UpAndDown$GameRules$Dependent
};

var GameRules = {
  foundationOffset: 320,
  Item: Item,
  item_encode: item_encode,
  item_decode: item_decode,
  space_encode: space_encode,
  space_decode: space_decode,
  getSpace: getSpace,
  spaceToString: spaceToString,
  fullDeck: fullDeck,
  deckToDeal: deckToDeal,
  initiateGame: initiateGame,
  getSpaceLocs: getSpaceLocs,
  baseSpace: baseSpace,
  canDrag: canDrag,
  canDrop: canDrop,
  onDrop: onDrop,
  applyMoveToOthers: applyMoveToOthers,
  autoProgress: autoProgress,
  Independent: Independent,
  Dependent: Dependent
};

var Game = GameBase.GameBase({
      getSpace: getSpace,
      spaceToString: spaceToString,
      initiateGame: initiateGame,
      getSpaceLocs: getSpaceLocs,
      applyMoveToOthers: applyMoveToOthers,
      canDrag: canDrag,
      canDrop: canDrop,
      onDrop: onDrop,
      autoProgress: autoProgress,
      Independent: Independent,
      Dependent: Dependent
    });

export {
  GameRules ,
  Game ,
}
/* fullDeck Not a pure module */
