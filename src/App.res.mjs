// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import TestJsx from "./Test.jsx";
import * as Caml_module from "rescript/lib/es6/caml_module.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Core from "@dnd-kit/core";
import * as JsxRuntime from "react/jsx-runtime";

var allRanks = [
  "RA",
  "R2",
  "R3",
  "R4",
  "R5",
  "R6",
  "R7",
  "R8",
  "R9",
  "R10",
  "RJ",
  "RQ",
  "RK"
];

var allSuits = [
  "Spades",
  "Hearts",
  "Diamonds",
  "Clubs"
];

function isRed(card) {
  if (card.suit === "Hearts") {
    return true;
  } else {
    return card.suit === "Diamonds";
  }
}

function rankIsBelow(a, b) {
  var match = a.rank;
  var match$1 = b.rank;
  switch (match) {
    case "RA" :
        if (match$1 === "R2") {
          return true;
        } else {
          return false;
        }
    case "R2" :
        if (match$1 === "R3") {
          return true;
        } else {
          return false;
        }
    case "R3" :
        if (match$1 === "R4") {
          return true;
        } else {
          return false;
        }
    case "R4" :
        if (match$1 === "R5") {
          return true;
        } else {
          return false;
        }
    case "R5" :
        if (match$1 === "R6") {
          return true;
        } else {
          return false;
        }
    case "R6" :
        if (match$1 === "R7") {
          return true;
        } else {
          return false;
        }
    case "R7" :
        if (match$1 === "R8") {
          return true;
        } else {
          return false;
        }
    case "R8" :
        if (match$1 === "R9") {
          return true;
        } else {
          return false;
        }
    case "R9" :
        if (match$1 === "R10") {
          return true;
        } else {
          return false;
        }
    case "R10" :
        if (match$1 === "RJ") {
          return true;
        } else {
          return false;
        }
    case "RJ" :
        if (match$1 === "RQ") {
          return true;
        } else {
          return false;
        }
    case "RQ" :
        if (match$1 === "RK") {
          return true;
        } else {
          return false;
        }
    case "RK" :
        return false;
    
  }
}

function rankIsAbove(a, b) {
  var match = a.rank;
  var match$1 = b.rank;
  switch (match) {
    case "RA" :
        return false;
    case "R2" :
        if (match$1 === "RA") {
          return true;
        } else {
          return false;
        }
    case "R3" :
        if (match$1 === "R2") {
          return true;
        } else {
          return false;
        }
    case "R4" :
        if (match$1 === "R3") {
          return true;
        } else {
          return false;
        }
    case "R5" :
        if (match$1 === "R4") {
          return true;
        } else {
          return false;
        }
    case "R6" :
        if (match$1 === "R5") {
          return true;
        } else {
          return false;
        }
    case "R7" :
        if (match$1 === "R6") {
          return true;
        } else {
          return false;
        }
    case "R8" :
        if (match$1 === "R7") {
          return true;
        } else {
          return false;
        }
    case "R9" :
        if (match$1 === "R8") {
          return true;
        } else {
          return false;
        }
    case "R10" :
        if (match$1 === "R9") {
          return true;
        } else {
          return false;
        }
    case "RJ" :
        if (match$1 === "R10") {
          return true;
        } else {
          return false;
        }
    case "RQ" :
        if (match$1 === "RJ") {
          return true;
        } else {
          return false;
        }
    case "RK" :
        if (match$1 === "RQ") {
          return true;
        } else {
          return false;
        }
    
  }
}

function rankString(card) {
  var match = card.rank;
  switch (match) {
    case "RA" :
        return "A";
    case "R2" :
        return "2";
    case "R3" :
        return "3";
    case "R4" :
        return "4";
    case "R5" :
        return "5";
    case "R6" :
        return "6";
    case "R7" :
        return "7";
    case "R8" :
        return "8";
    case "R9" :
        return "9";
    case "R10" :
        return "10";
    case "RJ" :
        return "J";
    case "RQ" :
        return "Q";
    case "RK" :
        return "K";
    
  }
}

function suitString(card) {
  var match = card.suit;
  switch (match) {
    case "Spades" :
        return "♠";
    case "Hearts" :
        return "♥";
    case "Diamonds" :
        return "♦";
    case "Clubs" :
        return "♣";
    
  }
}

function string(card) {
  var match = card.rank;
  var tmp;
  tmp = match === "R10" ? "tracking-[-0.1rem] w-4" : "w-3.5";
  return JsxRuntime.jsxs("span", {
              children: [
                JsxRuntime.jsxs("span", {
                      children: [
                        JsxRuntime.jsx("span", {
                              children: rankString(card),
                              className: [
                                  "font-medium ",
                                  tmp
                                ].join(" ")
                            }),
                        JsxRuntime.jsx("span", {
                              children: suitString(card),
                              className: "w-3.5 flex flex-row justify-center"
                            })
                      ],
                      className: "flex flex-row"
                    }),
                JsxRuntime.jsx("span", {
                      children: suitString(card),
                      className: "w-3.5 flex flex-row mt-0.5 -ml-0.5"
                    })
              ],
              className: "flex flex-col"
            });
}

function color(card) {
  var match = card.suit;
  switch (match) {
    case "Hearts" :
    case "Diamonds" :
        return "hsl(0 100% 44.31%)";
    case "Spades" :
    case "Clubs" :
        return "hsl(0 0% 0%)";
    
  }
}

function isOppositeColor(a, b) {
  return isRed(a) !== isRed(b);
}

function rotation(card) {
  var suitJitter = allSuits.findIndex(function (s) {
        return s === card.suit;
      }) - 2 | 0;
  var rankJitter = allRanks.findIndex(function (r) {
        return r === card.rank;
      }) % 4 - 2 | 0;
  return "rotate(" + (suitJitter + rankJitter | 0).toString() + "deg)";
}

function getShuffledDeck() {
  return Core__Array.toShuffled(Core__Array.reduce(allRanks, [], (function (a, rank) {
                    return Core__Array.reduce(allSuits, a, (function (a2, suit) {
                                  return a2.concat([{
                                                suit: suit,
                                                rank: rank,
                                                revealed: false
                                              }]);
                                }));
                  })));
}

function canPutOnPile(a, b, param) {
  if (a.revealed && b.revealed && rankIsAbove(a, b)) {
    return isOppositeColor(a, b);
  } else {
    return false;
  }
}

function canPutOnFoundation(a, b, hasOnTop) {
  if (!hasOnTop && a.revealed && b.revealed && rankIsBelow(a, b)) {
    return a.suit === b.suit;
  } else {
    return false;
  }
}

function initiateGame() {
  var shuffledDeck = getShuffledDeck();
  return {
          piles: [
            shuffledDeck.slice(0, 1),
            shuffledDeck.slice(1, 3),
            shuffledDeck.slice(3, 6),
            shuffledDeck.slice(6, 10),
            shuffledDeck.slice(10, 15),
            shuffledDeck.slice(15, 21),
            shuffledDeck.slice(21, 28)
          ],
          foundations: [
            [],
            [],
            [],
            []
          ],
          stock: shuffledDeck.slice(28),
          waste: [],
          gameEnded: false
        };
}

function App$DropZone(props) {
  var __empty = props.empty;
  var canDrop = props.canDrop;
  var empty = __empty !== undefined ? __empty : false;
  var match = Core.useDroppable({
        id: props.cardId
      });
  var isOver = match.isOver;
  return JsxRuntime.jsx("div", {
              ref: Caml_option.some(match.setNodeRef),
              className: [
                  "rounded h-[80px] w-[57px]",
                  empty ? (
                      isOver ? (
                          canDrop ? "opacity-0 bg-blue-200" : "opacity-0 bg-red-200"
                        ) : "bg-gray-200 "
                    ) : (
                      isOver ? (
                          canDrop ? "opacity-0 bg-blue-200" : "opacity-0 bg-red-200"
                        ) : "opacity-0"
                    )
                ].join(" ")
            });
}

function encodeDropId(d) {
  var tmp;
  switch (d.TAG) {
    case "PileBase" :
        tmp = [
          "PileBase",
          d._0.toString()
        ];
        break;
    case "FoundationBase" :
        tmp = [
          "FoundationBase",
          d._0.toString()
        ];
        break;
    case "PileChild" :
        tmp = [
          "PileChild",
          d._0.toString(),
          d._1.toString()
        ];
        break;
    case "FoundationChild" :
        tmp = [
          "FoundationChild",
          d._0.toString(),
          d._1.toString()
        ];
        break;
    case "Waste" :
        tmp = [
          "Waste",
          d._0.toString()
        ];
        break;
    
  }
  return tmp.join("-");
}

function decodeDropId(d) {
  var split = d.split("-");
  var len = split.length;
  if (len !== 2) {
    if (len !== 3) {
      return ;
    }
    var match = split[0];
    switch (match) {
      case "FoundationChild" :
          var num = split[1];
          var index = split[2];
          var match$1 = Core__Int.fromString(num, undefined);
          var match$2 = Core__Int.fromString(index, undefined);
          if (match$1 !== undefined && match$2 !== undefined) {
            return {
                    TAG: "FoundationChild",
                    _0: match$1,
                    _1: match$2
                  };
          } else {
            return ;
          }
      case "PileChild" :
          var num$1 = split[1];
          var index$1 = split[2];
          var match$3 = Core__Int.fromString(num$1, undefined);
          var match$4 = Core__Int.fromString(index$1, undefined);
          if (match$3 !== undefined && match$4 !== undefined) {
            return {
                    TAG: "PileChild",
                    _0: match$3,
                    _1: match$4
                  };
          } else {
            return ;
          }
      default:
        return ;
    }
  } else {
    var match$5 = split[0];
    switch (match$5) {
      case "FoundationBase" :
          var num$2 = split[1];
          var n = Core__Int.fromString(num$2, undefined);
          if (n !== undefined) {
            return {
                    TAG: "FoundationBase",
                    _0: n
                  };
          } else {
            return ;
          }
      case "PileBase" :
          var num$3 = split[1];
          var n$1 = Core__Int.fromString(num$3, undefined);
          if (n$1 !== undefined) {
            return {
                    TAG: "PileBase",
                    _0: n$1
                  };
          } else {
            return ;
          }
      case "Waste" :
          var index$2 = split[1];
          var n$2 = Core__Int.fromString(index$2, undefined);
          if (n$2 !== undefined) {
            return {
                    TAG: "Waste",
                    _0: n$2
                  };
          } else {
            return ;
          }
      default:
        return ;
    }
  }
}

var CardComp = Caml_module.init_mod([
      "App.res",
      339,
      32
    ], {
      TAG: "Module",
      _0: [[
          "Function",
          "make"
        ]]
    });

function make(param) {
  var movable = param.movable;
  var movingPile = param.movingPile;
  var place = param.place;
  var num = param.num;
  var index = param.index;
  var stack = param.stack;
  var card = stack[index];
  var onTop = stack[index + 1 | 0];
  var hasOnTop = Core__Option.isSome(onTop);
  var tmp;
  tmp = place === "Pile" ? ({
        TAG: "PileChild",
        _0: num,
        _1: index
      }) : ({
        TAG: "FoundationChild",
        _0: num,
        _1: index
      });
  var cardId = encodeDropId(tmp);
  var match = Core.useDraggable({
        id: cardId
      });
  var style = Core__Option.mapOr(Caml_option.nullable_to_opt(match.transform), {
        zIndex: movingPile ? "2" : "1",
        transform: "translate3d(0px, 0px, 0px)"
      }, (function (t) {
          return {
                  zIndex: "2",
                  transform: "translate3d(" + t.x.toString() + "px, " + t.y.toString() + "px, 0px)"
                };
        }));
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("div", {
                      children: string(card),
                      className: [
                          " border border-gray-300 rounded h-[80px] w-[57px] bg-white shadow-sm px-1 leading-none py-0.5 cursor-default",
                          place === "Pile" ? "-mb-[58px]" : "-mb-[80px]"
                        ].join(" "),
                      style: {
                        color: color(card),
                        transform: rotation(card)
                      }
                    }),
                hasOnTop ? JsxRuntime.jsx(CardComp.make, {
                        stack: stack,
                        index: index + 1 | 0,
                        num: num,
                        place: place,
                        canPutCardOnCard: param.canPutCardOnCard,
                        aligned: param.aligned,
                        movingPile: movingPile,
                        movable: movable
                      }) : JsxRuntime.jsx(App$DropZone, {
                        canDrop: true,
                        cardId: cardId
                      })
              ],
              ref: Caml_option.some(match.setNodeRef),
              style: style,
              onPointerDown: movable ? match.listeners.onPointerDown : (function (param) {
                    
                  })
            });
}

Caml_module.update_mod({
      TAG: "Module",
      _0: [[
          "Function",
          "make"
        ]]
    }, CardComp, {
      make: make
    });

function App$WasteCard(props) {
  var index = props.index;
  var card = props.card;
  var cardId = encodeDropId({
        TAG: "Waste",
        _0: index
      });
  var match = Core.useDraggable({
        id: cardId
      });
  var style = Core__Option.mapOr(Caml_option.nullable_to_opt(match.transform), {
        zIndex: "1",
        transform: "translate3d(0px, 0px, 0px)"
      }, (function (t) {
          return {
                  zIndex: "2",
                  transform: "translate3d(" + t.x.toString() + "px, " + t.y.toString() + "px, 0px)"
                };
        }));
  return JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx("div", {
                    children: string(card),
                    className: [
                        " border border-gray-300 rounded h-[80px] w-[57px] bg-white shadow-sm px-1 leading-none py-0.5 cursor-default",
                        index === 0 ? "" : "-ml-[37px]"
                      ].join(" "),
                    style: {
                      color: color(card),
                      position: "relative",
                      transform: rotation(card)
                    }
                  }),
              ref: Caml_option.some(match.setNodeRef),
              style: style,
              onPointerDown: props.movable ? match.listeners.onPointerDown : (function (param) {
                    
                  })
            });
}

function App$Pile(props) {
  var moving = props.moving;
  var stack = props.stack;
  var num = props.num;
  var movingPile = moving !== undefined && moving.TAG === "PileChild" ? moving._0 === num : false;
  if (stack.length !== 0) {
    return JsxRuntime.jsx(CardComp.make, {
                stack: stack,
                index: 0,
                num: num,
                place: "Pile",
                canPutCardOnCard: canPutOnPile,
                aligned: false,
                movingPile: movingPile,
                movable: true
              });
  } else {
    return JsxRuntime.jsx(App$DropZone, {
                canDrop: true,
                empty: true,
                cardId: encodeDropId({
                      TAG: "PileBase",
                      _0: num
                    })
              });
  }
}

function App$Foundation(props) {
  var stack = props.stack;
  var num = props.num;
  return JsxRuntime.jsx("div", {
              children: stack.length !== 0 ? JsxRuntime.jsx(CardComp.make, {
                      stack: stack,
                      index: 0,
                      num: num,
                      place: "Foundation",
                      canPutCardOnCard: canPutOnFoundation,
                      aligned: true,
                      movingPile: false,
                      movable: false
                    }) : JsxRuntime.jsx(App$DropZone, {
                      canDrop: true,
                      empty: true,
                      cardId: encodeDropId({
                            TAG: "FoundationBase",
                            _0: num
                          })
                    })
            });
}

function App$Stock(props) {
  var empty = props.empty;
  var onClick = props.onClick;
  return JsxRuntime.jsx("button", {
              children: empty ? "↩︎" : "",
              className: [
                  "h-[80px] w-[57px] rounded border",
                  empty ? "bg-gray-100 border-gray-300" : "bg-sky-900 border-transparent"
                ].join(" "),
              onClick: (function (param) {
                  onClick();
                })
            });
}

function App$Waste(props) {
  var waste = props.waste;
  console.log(waste);
  return JsxRuntime.jsx("div", {
              children: waste.map(function (wasteCard, index) {
                    return JsxRuntime.jsx(App$WasteCard, {
                                card: wasteCard,
                                index: index,
                                movable: index === (waste.length - 1 | 0)
                              });
                  }),
              className: "flex flex-row"
            });
}

var initialGame = initiateGame();

function App(props) {
  var match = React.useState(function () {
        
      });
  var setMoving = match[1];
  var moving = match[0];
  var match$1 = React.useState(function () {
        return {
                currentUndoDepth: 0,
                undos: []
              };
      });
  var setUndoStats = match$1[1];
  var undoStats = match$1[0];
  var match$2 = React.useState(function () {
        return {
                history: [initialGame]
              };
      });
  var setState = match$2[1];
  var state = match$2[0];
  var game = state.history[state.history.length - 1 | 0];
  var setGame = function (f) {
    if (undoStats.currentUndoDepth > 0) {
      setUndoStats(function (undoStats) {
            return {
                    currentUndoDepth: 0,
                    undos: undoStats.undos.concat([undoStats.currentUndoDepth])
                  };
          });
    }
    setState(function (state) {
          var newGame = f(game);
          return {
                  history: state.history.concat([newGame])
                };
        });
  };
  var undo = function () {
    if (state.history.length > 1) {
      setState(function (state) {
            return {
                    history: state.history.slice(0, state.history.length - 1 | 0)
                  };
          });
      return setUndoStats(function (undoStats) {
                  return {
                          currentUndoDepth: undoStats.currentUndoDepth + 1 | 0,
                          undos: undoStats.undos
                        };
                });
    }
    
  };
  var waste = game.waste;
  var foundations = game.foundations;
  var piles = game.piles;
  var pileGet = function (a, b) {
    return piles[a][b];
  };
  var pileSlice = function (a, b) {
    return piles[a].slice(b);
  };
  var foundationGet = function (a, b) {
    return foundations[a][b];
  };
  var restart = function (param) {
    setUndoStats(function (param) {
          return {
                  currentUndoDepth: 0,
                  undos: []
                };
        });
    setState(function (s) {
          return {
                  history: [s.history[0]]
                };
        });
  };
  var onDragEnd = function (dragEndEvent) {
    var dropSpace = decodeDropId(dragEndEvent.over.id);
    var dragSpace = decodeDropId(dragEndEvent.active.id);
    if (dragSpace !== undefined) {
      switch (dragSpace.TAG) {
        case "PileChild" :
            var dragIndex = dragSpace._1;
            var dragNum = dragSpace._0;
            var dragPileSize = piles[dragNum].length;
            var dragCard = pileGet(dragNum, dragIndex);
            var dragHasChildren = dragIndex < (dragPileSize - 1 | 0);
            var dragSlice = pileSlice(dragNum, dragIndex);
            if (dropSpace !== undefined) {
              switch (dropSpace.TAG) {
                case "PileBase" :
                    var dropNum = dropSpace._0;
                    setGame(function (game) {
                          return {
                                  piles: game.piles.map(function (pile, i) {
                                        if (i === dragNum) {
                                          return pile.slice(0, dragIndex);
                                        } else if (i === dropNum) {
                                          return pile.concat(dragSlice);
                                        } else {
                                          return pile;
                                        }
                                      }),
                                  foundations: game.foundations,
                                  stock: game.stock,
                                  waste: game.waste,
                                  gameEnded: game.gameEnded
                                };
                        });
                    break;
                case "FoundationBase" :
                    if (dragCard.rank === "RA" && !dragHasChildren) {
                      var dropNum$1 = dropSpace._0;
                      setGame(function (game) {
                            return {
                                    piles: game.piles.map(function (pile, i) {
                                          if (i === dragNum) {
                                            return pile.slice(0, dragIndex);
                                          } else {
                                            return pile;
                                          }
                                        }),
                                    foundations: game.foundations.map(function (foundation, i) {
                                          if (i === dropNum$1) {
                                            return foundation.concat(dragSlice);
                                          } else {
                                            return foundation;
                                          }
                                        }),
                                    stock: game.stock,
                                    waste: game.waste,
                                    gameEnded: game.gameEnded
                                  };
                          });
                    }
                    break;
                case "PileChild" :
                    var dropIndex = dropSpace._1;
                    var dropNum$2 = dropSpace._0;
                    var dropPileSize = piles[dropNum$2].length;
                    var dropCard = pileGet(dropNum$2, dropIndex);
                    var dropHasChildren = dropIndex < (dropPileSize - 1 | 0);
                    if (rankIsBelow(dragCard, dropCard) && isOppositeColor(dragCard, dropCard) && !dropHasChildren) {
                      setGame(function (game) {
                            return {
                                    piles: game.piles.map(function (pile, i) {
                                          if (i === dragNum) {
                                            return pile.slice(0, dragIndex);
                                          } else if (i === dropNum$2) {
                                            return pile.concat(dragSlice);
                                          } else {
                                            return pile;
                                          }
                                        }),
                                    foundations: game.foundations,
                                    stock: game.stock,
                                    waste: game.waste,
                                    gameEnded: game.gameEnded
                                  };
                          });
                    }
                    break;
                case "FoundationChild" :
                    var dropNum$3 = dropSpace._0;
                    var dropCard$1 = foundationGet(dropNum$3, dropSpace._1);
                    if (rankIsAbove(dragCard, dropCard$1) && dragCard.suit === dropCard$1.suit && !dragHasChildren) {
                      setGame(function (game) {
                            return {
                                    piles: game.piles.map(function (pile, i) {
                                          if (i === dragNum) {
                                            return pile.slice(0, dragIndex);
                                          } else {
                                            return pile;
                                          }
                                        }),
                                    foundations: game.foundations.map(function (foundation, i) {
                                          if (i === dropNum$3) {
                                            return foundation.concat(dragSlice);
                                          } else {
                                            return foundation;
                                          }
                                        }),
                                    stock: game.stock,
                                    waste: game.waste,
                                    gameEnded: game.gameEnded
                                  };
                          });
                    }
                    break;
                case "Waste" :
                    break;
                
              }
            }
            break;
        case "Waste" :
            var dragCard$1 = waste[dragSpace._0];
            var dragSlice$1 = [dragCard$1];
            if (dropSpace !== undefined) {
              switch (dropSpace.TAG) {
                case "PileBase" :
                    var dropNum$4 = dropSpace._0;
                    setGame(function (game) {
                          return {
                                  piles: game.piles.map(function (pile, i) {
                                        if (i === dropNum$4) {
                                          return dragSlice$1;
                                        } else {
                                          return pile;
                                        }
                                      }),
                                  foundations: game.foundations,
                                  stock: game.stock,
                                  waste: game.waste.slice(0, game.waste.length - 1 | 0),
                                  gameEnded: game.gameEnded
                                };
                        });
                    break;
                case "FoundationBase" :
                    if (dragCard$1.rank === "RA") {
                      var dropNum$5 = dropSpace._0;
                      setGame(function (game) {
                            return {
                                    piles: game.piles,
                                    foundations: game.foundations.map(function (foundation, i) {
                                          if (i === dropNum$5) {
                                            return dragSlice$1;
                                          } else {
                                            return foundation;
                                          }
                                        }),
                                    stock: game.stock,
                                    waste: game.waste.slice(0, game.waste.length - 1 | 0),
                                    gameEnded: game.gameEnded
                                  };
                          });
                    }
                    break;
                case "PileChild" :
                    var dropIndex$1 = dropSpace._1;
                    var dropNum$6 = dropSpace._0;
                    var dropPileSize$1 = piles[dropNum$6].length;
                    var dropCard$2 = pileGet(dropNum$6, dropIndex$1);
                    var dropHasChildren$1 = dropIndex$1 < (dropPileSize$1 - 1 | 0);
                    if (rankIsBelow(dragCard$1, dropCard$2) && isOppositeColor(dragCard$1, dropCard$2) && !dropHasChildren$1) {
                      setGame(function (game) {
                            return {
                                    piles: game.piles.map(function (pile, i) {
                                          if (i === dropNum$6) {
                                            return pile.concat(dragSlice$1);
                                          } else {
                                            return pile;
                                          }
                                        }),
                                    foundations: game.foundations,
                                    stock: game.stock,
                                    waste: game.waste.slice(0, game.waste.length - 1 | 0),
                                    gameEnded: game.gameEnded
                                  };
                          });
                    }
                    break;
                case "FoundationChild" :
                    var dropNum$7 = dropSpace._0;
                    var dropCard$3 = foundationGet(dropNum$7, dropSpace._1);
                    if (rankIsAbove(dragCard$1, dropCard$3) && dragCard$1.suit === dropCard$3.suit) {
                      setGame(function (game) {
                            return {
                                    piles: game.piles,
                                    foundations: game.foundations.map(function (foundation, i) {
                                          if (i === dropNum$7) {
                                            return foundation.concat(dragSlice$1);
                                          } else {
                                            return foundation;
                                          }
                                        }),
                                    stock: game.stock,
                                    waste: game.waste.slice(0, game.waste.length - 1 | 0),
                                    gameEnded: game.gameEnded
                                  };
                          });
                    }
                    break;
                case "Waste" :
                    break;
                
              }
            }
            break;
        default:
          
      }
    }
    setMoving(function (param) {
          
        });
  };
  var sum = function (arr) {
    return Core__Array.reduce(arr, 0, (function (a, c) {
                  return a + c | 0;
                }));
  };
  var max = function (arr) {
    return Core__Array.reduce(arr, 0, (function (a, c) {
                  return Math.max(a, c);
                })) | 0;
  };
  var dealFromStock = function () {
    setGame(function (game) {
          var numDealt = game.stock.length > 3 ? 3 : game.stock.length;
          return {
                  piles: game.piles,
                  foundations: game.foundations,
                  stock: game.stock.slice(numDealt),
                  waste: game.waste.concat(game.stock.slice(0, numDealt)),
                  gameEnded: game.gameEnded
                };
        });
  };
  var restock = function () {
    setGame(function (game) {
          return {
                  piles: game.piles,
                  foundations: game.foundations,
                  stock: game.waste,
                  waste: [],
                  gameEnded: game.gameEnded
                };
        });
  };
  var onDragStart = function ($$event) {
    setMoving(function (param) {
          return decodeDropId($$event.active.id);
        });
  };
  var onDragCancel = function () {
    setMoving(function (param) {
          
        });
  };
  var stockEmpty = game.stock.length === 0;
  var gameEnded = game.foundations.every(function (f) {
        return f.length === 13;
      });
  return JsxRuntime.jsx(Core.DndContext, {
              children: JsxRuntime.jsxs("div", {
                    children: [
                      JsxRuntime.jsxs("div", {
                            children: [
                              JsxRuntime.jsx("button", {
                                    children: "Restart",
                                    className: "bg-gray-900 text-white px-2 rounded text-sm",
                                    onClick: restart
                                  }),
                              JsxRuntime.jsx("button", {
                                    children: "Undo",
                                    className: "bg-gray-900 text-white px-2 rounded text-sm ml-1",
                                    onClick: (function (param) {
                                        undo();
                                      })
                                  }),
                              JsxRuntime.jsxs("div", {
                                    children: [
                                      JsxRuntime.jsx("div", {
                                            children: "# Moves: " + (state.history.length - 1 | 0).toString(),
                                            className: " px-2 flex flex-row gap-2"
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: "# Undos: " + (undoStats.currentUndoDepth + sum(undoStats.undos) | 0).toString(),
                                            className: " px-2 flex flex-row gap-2"
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: "# Undo Branches: " + (undoStats.undos.length + (
                                                  undoStats.currentUndoDepth > 0 ? 1 : 0
                                                ) | 0).toString(),
                                            className: " px-2 flex flex-row gap-2"
                                          }),
                                      JsxRuntime.jsx("div", {
                                            children: "Max Undo Depth: " + max(undoStats.undos.concat([undoStats.currentUndoDepth])).toString(),
                                            className: " px-2 flex flex-row gap-2"
                                          })
                                    ],
                                    className: "flex flex-col text-xs bg-gray-200 p-1 py-2 w-40 rounded-lg my-1"
                                  }),
                              JsxRuntime.jsx("div", {
                                    children: gameEnded ? "You win!" : null
                                  })
                            ]
                          }),
                      JsxRuntime.jsxs("div", {
                            children: [
                              JsxRuntime.jsx(App$Stock, {
                                    onClick: stockEmpty ? restock : dealFromStock,
                                    empty: stockEmpty
                                  }),
                              JsxRuntime.jsx(App$Waste, {
                                    waste: game.waste
                                  })
                            ],
                            className: "flex flex-row gap-2 py-1"
                          }),
                      JsxRuntime.jsxs("div", {
                            children: [
                              JsxRuntime.jsx(App$Foundation, {
                                    num: 0,
                                    stack: foundations[0]
                                  }),
                              JsxRuntime.jsx(App$Foundation, {
                                    num: 1,
                                    stack: foundations[1]
                                  }),
                              JsxRuntime.jsx(App$Foundation, {
                                    num: 2,
                                    stack: foundations[2]
                                  }),
                              JsxRuntime.jsx(App$Foundation, {
                                    num: 3,
                                    stack: foundations[3]
                                  })
                            ],
                            className: "flex flex-row gap-2 py-1"
                          }),
                      JsxRuntime.jsxs("div", {
                            children: [
                              JsxRuntime.jsx(App$Pile, {
                                    num: 0,
                                    stack: piles[0],
                                    moving: moving
                                  }),
                              JsxRuntime.jsx(App$Pile, {
                                    num: 1,
                                    stack: piles[1],
                                    moving: moving
                                  }),
                              JsxRuntime.jsx(App$Pile, {
                                    num: 2,
                                    stack: piles[2],
                                    moving: moving
                                  }),
                              JsxRuntime.jsx(App$Pile, {
                                    num: 3,
                                    stack: piles[3],
                                    moving: moving
                                  }),
                              JsxRuntime.jsx(App$Pile, {
                                    num: 4,
                                    stack: piles[4],
                                    moving: moving
                                  }),
                              JsxRuntime.jsx(App$Pile, {
                                    num: 5,
                                    stack: piles[5],
                                    moving: moving
                                  }),
                              JsxRuntime.jsx(App$Pile, {
                                    num: 6,
                                    stack: piles[6],
                                    moving: moving
                                  })
                            ],
                            className: "flex flex-row gap-2 py-1"
                          })
                    ],
                    className: "p-6"
                  }),
              onDragEnd: onDragEnd,
              onDragStart: onDragStart,
              onDragCancel: onDragCancel
            });
}

var make$1 = App;

export {
  make$1 as make,
}
/*  Not a pure module */
